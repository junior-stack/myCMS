
<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
      
        <link rel="canonical" href="https://juniorxyz.github.io/myCMS/Algorithm/">
      
      
        <link rel="prev" href="..">
      
      
        <link rel="next" href="../CheatSheet/">
      
      
      <link rel="icon" href="../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.6.1, mkdocs-material-9.6.22">
    
    
      
        <title>Algorithm - My Docs</title>
      
    
    
      <link rel="stylesheet" href="../assets/stylesheets/main.84d31ad4.min.css">
      
      


    
    
      
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
    
      <link rel="stylesheet" href="../css/collapseCodeblock.css">
    
    <script>__md_scope=new URL("..",location),__md_hash=e=>[...e].reduce(((e,_)=>(e<<5)-e+_.charCodeAt(0)),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
    
  </head>
  
  
    <body dir="ltr">
  
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#0-basis" class="md-skip">
          Skip to content
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

  

<header class="md-header md-header--shadow" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="Header">
    <a href=".." title="My Docs" class="md-header__button md-logo" aria-label="My Docs" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54"/></svg>

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3zm0 5h18v2H3zm0 5h18v2H3z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            My Docs
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              Algorithm
            
          </span>
        </div>
      </div>
    </div>
    
    
      <script>var palette=__md_get("__palette");if(palette&&palette.color){if("(prefers-color-scheme)"===palette.color.media){var media=matchMedia("(prefers-color-scheme: light)"),input=document.querySelector(media.matches?"[data-md-color-media='(prefers-color-scheme: light)']":"[data-md-color-media='(prefers-color-scheme: dark)']");palette.color.media=input.getAttribute("data-md-color-media"),palette.color.scheme=input.getAttribute("data-md-color-scheme"),palette.color.primary=input.getAttribute("data-md-color-primary"),palette.color.accent=input.getAttribute("data-md-color-accent")}for(var[key,value]of Object.entries(palette.color))document.body.setAttribute("data-md-color-"+key,value)}</script>
    
    
    
      
      
        <label class="md-header__button md-icon" for="__search">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
        </label>
        <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="Search" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="Search">
        
        <button type="reset" class="md-search__icon md-icon" title="Clear" aria-label="Clear" tabindex="-1">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/></svg>
        </button>
      </nav>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" tabindex="0" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Initializing search
          </div>
          <ol class="md-search-result__list" role="presentation"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
      
    
    
      <div class="md-header__source">
        <a href="https://github.com/junior-stack/myCMS" title="Go to repository" class="md-source" data-md-component="source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 7.1.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2025 Fonticons, Inc.--><path d="M439.6 236.1 244 40.5c-5.4-5.5-12.8-8.5-20.4-8.5s-15 3-20.4 8.4L162.5 81l51.5 51.5c27.1-9.1 52.7 16.8 43.4 43.7l49.7 49.7c34.2-11.8 61.2 31 35.5 56.7-26.5 26.5-70.2-2.9-56-37.3L240.3 199v121.9c25.3 12.5 22.3 41.8 9.1 55-6.4 6.4-15.2 10.1-24.3 10.1s-17.8-3.6-24.3-10.1c-17.6-17.6-11.1-46.9 11.2-56v-123c-20.8-8.5-24.6-30.7-18.6-45L142.6 101 8.5 235.1C3 240.6 0 247.9 0 255.5s3 15 8.5 20.4l195.6 195.7c5.4 5.4 12.7 8.4 20.4 8.4s15-3 20.4-8.4l194.7-194.7c5.4-5.4 8.4-12.8 8.4-20.4s-3-15-8.4-20.4"/></svg>
  </div>
  <div class="md-source__repository">
    junior-stack/myCMS
  </div>
</a>
      </div>
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    



<nav class="md-nav md-nav--primary" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href=".." title="My Docs" class="md-nav__button md-logo" aria-label="My Docs" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54"/></svg>

    </a>
    My Docs
  </label>
  
    <div class="md-nav__source">
      <a href="https://github.com/junior-stack/myCMS" title="Go to repository" class="md-source" data-md-component="source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 7.1.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2025 Fonticons, Inc.--><path d="M439.6 236.1 244 40.5c-5.4-5.5-12.8-8.5-20.4-8.5s-15 3-20.4 8.4L162.5 81l51.5 51.5c27.1-9.1 52.7 16.8 43.4 43.7l49.7 49.7c34.2-11.8 61.2 31 35.5 56.7-26.5 26.5-70.2-2.9-56-37.3L240.3 199v121.9c25.3 12.5 22.3 41.8 9.1 55-6.4 6.4-15.2 10.1-24.3 10.1s-17.8-3.6-24.3-10.1c-17.6-17.6-11.1-46.9 11.2-56v-123c-20.8-8.5-24.6-30.7-18.6-45L142.6 101 8.5 235.1C3 240.6 0 247.9 0 255.5s3 15 8.5 20.4l195.6 195.7c5.4 5.4 12.7 8.4 20.4 8.4s15-3 20.4-8.4l194.7-194.7c5.4-5.4 8.4-12.8 8.4-20.4s-3-15-8.4-20.4"/></svg>
  </div>
  <div class="md-source__repository">
    junior-stack/myCMS
  </div>
</a>
    </div>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href=".." class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Home
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
    
  
  
  
    <li class="md-nav__item md-nav__item--active">
      
      <input class="md-nav__toggle md-toggle" type="checkbox" id="__toc">
      
      
      
        <label class="md-nav__link md-nav__link--active" for="__toc">
          
  
  
  <span class="md-ellipsis">
    Algorithm
    
  </span>
  

          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <a href="./" class="md-nav__link md-nav__link--active">
        
  
  
  <span class="md-ellipsis">
    Algorithm
    
  </span>
  

      </a>
      
        

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#0-basis" class="md-nav__link">
    <span class="md-ellipsis">
      0. Basis
    </span>
  </a>
  
    <nav class="md-nav" aria-label="0. Basis">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#01-built-in-module" class="md-nav__link">
    <span class="md-ellipsis">
      0.1 Built-in module
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#02-runtime-analysis" class="md-nav__link">
    <span class="md-ellipsis">
      0.2 Runtime Analysis
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#1" class="md-nav__link">
    <span class="md-ellipsis">
      1. 二分查找
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#2" class="md-nav__link">
    <span class="md-ellipsis">
      2. 滑动窗口
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#3-graph" class="md-nav__link">
    <span class="md-ellipsis">
      3. Graph
    </span>
  </a>
  
    <nav class="md-nav" aria-label="3. Graph">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#31-dfs" class="md-nav__link">
    <span class="md-ellipsis">
      3.1 DFS
    </span>
  </a>
  
    <nav class="md-nav" aria-label="3.1 DFS">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#311-detect-cycle" class="md-nav__link">
    <span class="md-ellipsis">
      3.1.1 Detect Cycle
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#32-bfs" class="md-nav__link">
    <span class="md-ellipsis">
      3.2 BFS
    </span>
  </a>
  
    <nav class="md-nav" aria-label="3.2 BFS">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#321-level-order-traversal" class="md-nav__link">
    <span class="md-ellipsis">
      3.2.1 level order traversal
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#322-shortest-path" class="md-nav__link">
    <span class="md-ellipsis">
      3.2.2 Shortest path
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#33-single-source-shortest-path" class="md-nav__link">
    <span class="md-ellipsis">
      3.3 Single-source shortest path
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#34-all-pairs-shortest-path" class="md-nav__link">
    <span class="md-ellipsis">
      3.4 All-pairs shortest path
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#35-mst" class="md-nav__link">
    <span class="md-ellipsis">
      3.5 MST
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#4-greedy-choiice" class="md-nav__link">
    <span class="md-ellipsis">
      4. Greedy choiice
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#5-dp" class="md-nav__link">
    <span class="md-ellipsis">
      5. DP
    </span>
  </a>
  
    <nav class="md-nav" aria-label="5. DP">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#51-palindromesubstring" class="md-nav__link">
    <span class="md-ellipsis">
      5.1 Palindrome/substring
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#52-other" class="md-nav__link">
    <span class="md-ellipsis">
      5.2 Other
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#6-backtracing" class="md-nav__link">
    <span class="md-ellipsis">
      6. backtracing
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#7-prefix-sum-array" class="md-nav__link">
    <span class="md-ellipsis">
      7. Prefix sum &amp; array
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#8" class="md-nav__link">
    <span class="md-ellipsis">
      8. 双指针
    </span>
  </a>
  
    <nav class="md-nav" aria-label="8. 双指针">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#81" class="md-nav__link">
    <span class="md-ellipsis">
      8.1 前后指针
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#82" class="md-nav__link">
    <span class="md-ellipsis">
      8.2 快慢指针
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#9-tree" class="md-nav__link">
    <span class="md-ellipsis">
      9. Tree
    </span>
  </a>
  
    <nav class="md-nav" aria-label="9. Tree">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#91-traversal" class="md-nav__link">
    <span class="md-ellipsis">
      9.1 traversal
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#92-avl-tree" class="md-nav__link">
    <span class="md-ellipsis">
      9.2 AVL Tree
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#10-heap" class="md-nav__link">
    <span class="md-ellipsis">
      10. Heap
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#11-linkedlist" class="md-nav__link">
    <span class="md-ellipsis">
      11. LinkedList
    </span>
  </a>
  
    <nav class="md-nav" aria-label="11. LinkedList">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#111-linkedlist" class="md-nav__link">
    <span class="md-ellipsis">
      11.1 合并LinkedList
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#112-linkedlist" class="md-nav__link">
    <span class="md-ellipsis">
      11.2 寻找LinkedList倒数位置或中点
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#113" class="md-nav__link">
    <span class="md-ellipsis">
      11.3 寻找环起点
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#12-disjoint-set" class="md-nav__link">
    <span class="md-ellipsis">
      12. Disjoint Set
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#13-trie" class="md-nav__link">
    <span class="md-ellipsis">
      13. Trie(前缀树)
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#14-monostack" class="md-nav__link">
    <span class="md-ellipsis">
      14. MonoStack
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#15-divide-conquer" class="md-nav__link">
    <span class="md-ellipsis">
      15. Divide &amp; Conquer
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#16-segment-tree" class="md-nav__link">
    <span class="md-ellipsis">
      16. Segment Tree
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#17-line-sweep" class="md-nav__link">
    <span class="md-ellipsis">
      17. Line sweep
    </span>
  </a>
  
    <nav class="md-nav" aria-label="17. Line sweep">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#171-cross-product-application" class="md-nav__link">
    <span class="md-ellipsis">
      17.1 Cross Product application
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#18-bit-operation" class="md-nav__link">
    <span class="md-ellipsis">
      18. Bit operation
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#19-mergesort" class="md-nav__link">
    <span class="md-ellipsis">
      19. MergeSort
    </span>
  </a>
  
</li>
      
    </ul>
  
</nav>
      
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../CheatSheet/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    CheatSheet
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../typescrpt/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Typescrpt
    
  </span>
  

      </a>
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#0-basis" class="md-nav__link">
    <span class="md-ellipsis">
      0. Basis
    </span>
  </a>
  
    <nav class="md-nav" aria-label="0. Basis">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#01-built-in-module" class="md-nav__link">
    <span class="md-ellipsis">
      0.1 Built-in module
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#02-runtime-analysis" class="md-nav__link">
    <span class="md-ellipsis">
      0.2 Runtime Analysis
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#1" class="md-nav__link">
    <span class="md-ellipsis">
      1. 二分查找
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#2" class="md-nav__link">
    <span class="md-ellipsis">
      2. 滑动窗口
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#3-graph" class="md-nav__link">
    <span class="md-ellipsis">
      3. Graph
    </span>
  </a>
  
    <nav class="md-nav" aria-label="3. Graph">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#31-dfs" class="md-nav__link">
    <span class="md-ellipsis">
      3.1 DFS
    </span>
  </a>
  
    <nav class="md-nav" aria-label="3.1 DFS">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#311-detect-cycle" class="md-nav__link">
    <span class="md-ellipsis">
      3.1.1 Detect Cycle
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#32-bfs" class="md-nav__link">
    <span class="md-ellipsis">
      3.2 BFS
    </span>
  </a>
  
    <nav class="md-nav" aria-label="3.2 BFS">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#321-level-order-traversal" class="md-nav__link">
    <span class="md-ellipsis">
      3.2.1 level order traversal
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#322-shortest-path" class="md-nav__link">
    <span class="md-ellipsis">
      3.2.2 Shortest path
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#33-single-source-shortest-path" class="md-nav__link">
    <span class="md-ellipsis">
      3.3 Single-source shortest path
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#34-all-pairs-shortest-path" class="md-nav__link">
    <span class="md-ellipsis">
      3.4 All-pairs shortest path
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#35-mst" class="md-nav__link">
    <span class="md-ellipsis">
      3.5 MST
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#4-greedy-choiice" class="md-nav__link">
    <span class="md-ellipsis">
      4. Greedy choiice
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#5-dp" class="md-nav__link">
    <span class="md-ellipsis">
      5. DP
    </span>
  </a>
  
    <nav class="md-nav" aria-label="5. DP">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#51-palindromesubstring" class="md-nav__link">
    <span class="md-ellipsis">
      5.1 Palindrome/substring
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#52-other" class="md-nav__link">
    <span class="md-ellipsis">
      5.2 Other
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#6-backtracing" class="md-nav__link">
    <span class="md-ellipsis">
      6. backtracing
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#7-prefix-sum-array" class="md-nav__link">
    <span class="md-ellipsis">
      7. Prefix sum &amp; array
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#8" class="md-nav__link">
    <span class="md-ellipsis">
      8. 双指针
    </span>
  </a>
  
    <nav class="md-nav" aria-label="8. 双指针">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#81" class="md-nav__link">
    <span class="md-ellipsis">
      8.1 前后指针
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#82" class="md-nav__link">
    <span class="md-ellipsis">
      8.2 快慢指针
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#9-tree" class="md-nav__link">
    <span class="md-ellipsis">
      9. Tree
    </span>
  </a>
  
    <nav class="md-nav" aria-label="9. Tree">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#91-traversal" class="md-nav__link">
    <span class="md-ellipsis">
      9.1 traversal
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#92-avl-tree" class="md-nav__link">
    <span class="md-ellipsis">
      9.2 AVL Tree
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#10-heap" class="md-nav__link">
    <span class="md-ellipsis">
      10. Heap
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#11-linkedlist" class="md-nav__link">
    <span class="md-ellipsis">
      11. LinkedList
    </span>
  </a>
  
    <nav class="md-nav" aria-label="11. LinkedList">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#111-linkedlist" class="md-nav__link">
    <span class="md-ellipsis">
      11.1 合并LinkedList
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#112-linkedlist" class="md-nav__link">
    <span class="md-ellipsis">
      11.2 寻找LinkedList倒数位置或中点
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#113" class="md-nav__link">
    <span class="md-ellipsis">
      11.3 寻找环起点
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#12-disjoint-set" class="md-nav__link">
    <span class="md-ellipsis">
      12. Disjoint Set
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#13-trie" class="md-nav__link">
    <span class="md-ellipsis">
      13. Trie(前缀树)
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#14-monostack" class="md-nav__link">
    <span class="md-ellipsis">
      14. MonoStack
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#15-divide-conquer" class="md-nav__link">
    <span class="md-ellipsis">
      15. Divide &amp; Conquer
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#16-segment-tree" class="md-nav__link">
    <span class="md-ellipsis">
      16. Segment Tree
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#17-line-sweep" class="md-nav__link">
    <span class="md-ellipsis">
      17. Line sweep
    </span>
  </a>
  
    <nav class="md-nav" aria-label="17. Line sweep">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#171-cross-product-application" class="md-nav__link">
    <span class="md-ellipsis">
      17.1 Cross Product application
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#18-bit-operation" class="md-nav__link">
    <span class="md-ellipsis">
      18. Bit operation
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#19-mergesort" class="md-nav__link">
    <span class="md-ellipsis">
      19. MergeSort
    </span>
  </a>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          
            <div class="md-content" data-md-component="content">
              <article class="md-content__inner md-typeset">
                
                  


  
  


  <h1>Algorithm</h1>

<h2 id="0-basis">0. Basis<a class="headerlink" href="#0-basis" title="Permanent link">&para;</a></h2>
<h3 id="01-built-in-module">0.1 Built-in module<a class="headerlink" href="#01-built-in-module" title="Permanent link">&para;</a></h3>
<p>Python:</p>
<ul>
<li>Bisect<ul>
<li><code>bisect_left(a, x, lo=0, hi=len(a)):</code>This function returns an insertion point in <code>a</code>that all elements to its left are less than <code>x</code>, and all elements to its right are greater than or equal to <code>x</code></li>
<li>bisect_right(a, x, lo=0, hi=len(a)):<code>This function returns an insertion point in</code>a` that all elements to the left are less than or equal to x, all elements to right are greater than x</li>
</ul>
</li>
<li>collections<ul>
<li>deque</li>
<li>defaultdict</li>
</ul>
</li>
<li>heapq</li>
<li>copy:<ul>
<li>deepcopy: create deepcopy for objects, including nested list, set and so on</li>
</ul>
</li>
</ul>
<h3 id="02-runtime-analysis">0.2 Runtime Analysis<a class="headerlink" href="#02-runtime-analysis" title="Permanent link">&para;</a></h3>
<p>Typical leetcode testcase compute machine can execute operations per second. Normally an optimal solution, with the largest input possible, would take less than seconds to terminate execution. Thus implies the following:</p>
<ul>
<li>n = <span class="arithmatex">\(10^9\)</span><ul>
<li>O(log n)（Don't think of O(n)) <span class="arithmatex">\(\Rightarrow\)</span> binary search(if input is sorted), disjointSet, segment tree, heap, AVL tree</li>
</ul>
</li>
<li>n = <span class="arithmatex">\(10^4\)</span><ul>
<li>O(n) <span class="arithmatex">\(\Rightarrow\)</span> Double pointers, prefix sum, greedy choice, DP with O(n)</li>
<li>O(n * logn) <span class="arithmatex">\(\Rightarrow\)</span> sort then binary search</li>
</ul>
</li>
<li>n = <span class="arithmatex">\(10^3\)</span><ul>
<li>O(<span class="arithmatex">\(n^2\)</span>) <span class="arithmatex">\(\Rightarrow\)</span> 2D array, 2D-DP</li>
</ul>
</li>
<li>n = <span class="arithmatex">\(10^2\)</span><ul>
<li>O(<span class="arithmatex">\(n^3\)</span>) <span class="arithmatex">\(\Rightarrow\)</span> nested tripple loop</li>
</ul>
</li>
<li>n = 10<ul>
<li>O(<span class="arithmatex">\(2^n\)</span>), O(n!) <span class="arithmatex">\(\Rightarrow\)</span> DFS, brute force, permutation, backtracing(recursion)</li>
</ul>
</li>
</ul>
<h2 id="1">1. 二分查找<a class="headerlink" href="#1" title="Permanent link">&para;</a></h2>
<p>Note:</p>
<ul>
<li>取<code>arr[i..j]</code>左中点: <code>(i + j) // 2</code></li>
<li>取<code>arr[i..j]</code>右中点: <code>(i + j + 1) // 2</code>
Template(General template for finding element in sorted array):</li>
</ul>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">binary_search</span><span class="p">(</span><span class="n">lst</span><span class="p">,</span> <span class="n">target</span><span class="p">):</span>
    <span class="n">left</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">right</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">lst</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>

    <span class="k">while</span> <span class="n">left</span> <span class="o">&lt;=</span> <span class="n">right</span><span class="p">:</span>
        <span class="n">mid</span> <span class="o">=</span> <span class="p">(</span><span class="n">left</span> <span class="o">+</span> <span class="n">right</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span>

        <span class="k">if</span> <span class="n">lst</span><span class="p">[</span><span class="n">mid</span><span class="p">]</span> <span class="o">==</span> <span class="n">target</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">mid</span>
        <span class="k">elif</span> <span class="n">lst</span><span class="p">[</span><span class="n">mid</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">target</span><span class="p">:</span>
            <span class="n">left</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">right</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">-</span> <span class="mi">1</span>

    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>      
</code></pre></div>
<p>Variant template:</p>
<ul>
<li>Find the first or last target in a sorted array that contains duplicate elements</li>
<li>Find the insert position of target (Note: insert_position may &gt; len(nums - 1)) </li>
<li>Find the position of the element in nums that is larger than or equal to target</li>
</ul>
<div class="tabbed-set tabbed-alternate" data-tabs="1:2"><input checked="checked" id="__tabbed_1_1" name="__tabbed_1" type="radio" /><input id="__tabbed_1_2" name="__tabbed_1" type="radio" /><div class="tabbed-labels"><label for="__tabbed_1_1">python</label><label for="__tabbed_1_2">Java</label></div>
<div class="tabbed-content">
<div class="tabbed-block">
<div class="highlight"><pre><span></span><code><span class="c1"># lower is true, then find the first target index</span>
<span class="c1"># lower is false, then find the last target index</span>
<span class="k">def</span><span class="w"> </span><span class="nf">binarySearch</span><span class="p">(</span><span class="n">nums</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">lower</span><span class="p">):</span>
    <span class="n">left</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">right</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="n">ans</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span>
    <span class="c1"># 5, 5, 6; target = 5</span>
    <span class="k">while</span> <span class="n">left</span> <span class="o">&lt;=</span> <span class="n">right</span><span class="p">:</span>
        <span class="n">mid</span> <span class="o">=</span> <span class="p">(</span><span class="n">left</span> <span class="o">+</span> <span class="n">right</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span>

        <span class="k">if</span> <span class="n">nums</span><span class="p">[</span><span class="n">mid</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">target</span> <span class="ow">or</span> <span class="p">(</span><span class="n">lower</span> <span class="ow">and</span> <span class="n">nums</span><span class="p">[</span><span class="n">mid</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">target</span><span class="p">):</span>
            <span class="n">right</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">-</span> <span class="mi">1</span>
            <span class="c1"># if below line is moved to else block,</span>
            <span class="c1"># ans should be initialized to -1</span>
            <span class="c1"># return line should be return ans + 1 if lower else ans</span>
            <span class="n">ans</span> <span class="o">=</span> <span class="n">mid</span> 
        <span class="k">else</span><span class="p">:</span>
            <span class="n">left</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="n">ans</span> <span class="k">if</span> <span class="n">lower</span> <span class="k">else</span> <span class="n">ans</span> <span class="o">-</span> <span class="mi">1</span>
</code></pre></div>
</div>
<div class="tabbed-block">
<div class="highlight"><pre><span></span><code><span class="kd">class</span> <span class="nc">Solution</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">//  find first</span>
<span class="w">    </span><span class="c1">// find last lst[mid] &lt;= target</span>
<span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">binarySearch</span><span class="p">(</span><span class="n">lst</span><span class="p">:</span><span class="w"> </span><span class="kt">int</span><span class="o">[]</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">target</span><span class="p">,</span><span class="w"> </span><span class="kt">boolean</span><span class="w"> </span><span class="n">findFirst</span><span class="p">){</span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">left</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">right</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">lst</span><span class="p">.</span><span class="na">length</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">ans</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">lst</span><span class="p">.</span><span class="na">length</span><span class="p">;</span>
<span class="w">        </span><span class="k">while</span><span class="p">(</span><span class="n">left</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">right</span><span class="p">){</span>
<span class="w">            </span><span class="kt">int</span><span class="w"> </span><span class="n">mid</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">left</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">right</span><span class="p">)</span><span class="w"> </span><span class="o">&gt;&gt;&gt;</span><span class="w"> </span><span class="mi">1</span><span class="err">；</span>

<span class="w">            </span><span class="k">if</span><span class="p">(</span><span class="n">lst</span><span class="o">[</span><span class="n">mid</span><span class="o">]</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">target</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">findFirst</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">lst</span><span class="o">[</span><span class="n">mid</span><span class="o">]</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="n">target</span><span class="p">){</span>
<span class="w">                </span><span class="n">right</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">mid</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">                </span><span class="n">ans</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">mid</span><span class="p">;</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">            </span><span class="k">else</span><span class="p">{</span>
<span class="w">                </span><span class="n">left</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">mid</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">ans</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="n">findFirst</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="n">ans</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>


<span class="p">}</span>
</code></pre></div>
</div>
</div>
</div>
<ul>
<li>二分比较条件(思路来源于Search in Rotated Sorted Array， leetcode: #33)
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">binaryCompare</span><span class="p">(</span><span class="n">nums</span><span class="p">):</span>
    <span class="n">l</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">r</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="n">mid</span> <span class="o">=</span> <span class="p">(</span><span class="n">l</span> <span class="o">+</span> <span class="n">r</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span>
    <span class="n">ans</span> <span class="o">=</span> <span class="n">mid</span>
    <span class="k">while</span> <span class="n">l</span> <span class="o">&lt;=</span> <span class="n">r</span><span class="p">:</span>
        <span class="k">if</span> <span class="o">...</span><span class="p">:</span>  <span class="c1"># 关于nums[mid]的条件</span>
            <span class="n">l</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="k">elif</span> <span class="o">...</span><span class="p">:</span> <span class="c1"># 关于nums[mid]的条件</span>
            <span class="n">r</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">-</span> <span class="mi">1</span>

        <span class="k">if</span> <span class="o">...</span><span class="p">:</span> <span class="c1"># 关于nums[mid]的条件</span>
            <span class="n">ans</span> <span class="o">=</span> <span class="n">mid</span>
            <span class="k">break</span>

        <span class="n">mid</span> <span class="o">=</span> <span class="p">(</span><span class="n">l</span> <span class="o">+</span> <span class="n">r</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span>
    <span class="k">return</span> <span class="n">ans</span>  
</code></pre></div></li>
</ul>
<p>题:</p>
<ul>
<li><a href="https://leetcode.com/problems/insert-interval/">Insert Interval</a> (leetcode: #57_)</li>
<li>Lintcode #483:(ans: https://www.jiuzhang.com/problem/copy-books-ii/, quite similar to server selection under greedy, but not the same problem type)</li>
<li>Find Peak element(Leetcode: #162)</li>
<li>Find the range(Leetcode: #34)</li>
</ul>
<p><div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">insert</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">intervals</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]],</span> <span class="n">newInterval</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]]:</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">intervals</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[</span><span class="n">newInterval</span><span class="p">]</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">intervals</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">newInterval</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">intervals</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]:</span>
                <span class="k">if</span> <span class="n">newInterval</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">intervals</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]:</span>
                    <span class="k">return</span> <span class="p">[[</span><span class="n">intervals</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="nb">max</span><span class="p">(</span><span class="n">intervals</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="n">newInterval</span><span class="p">[</span><span class="mi">1</span><span class="p">])]]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">return</span> <span class="p">[</span><span class="n">intervals</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">newInterval</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">newInterval</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">intervals</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]:</span>
                    <span class="k">return</span> <span class="p">[[</span><span class="n">newInterval</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">max</span><span class="p">(</span><span class="n">newInterval</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">intervals</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">])]]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">return</span> <span class="p">[</span><span class="n">newInterval</span><span class="p">,</span> <span class="n">intervals</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>

        <span class="n">lower_start</span><span class="p">,</span> <span class="n">upper_start</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">find_position</span><span class="p">(</span><span class="n">intervals</span><span class="p">,</span> <span class="n">newInterval</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">lower_end</span><span class="p">,</span> <span class="n">upper_end</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">find_position</span><span class="p">(</span><span class="n">intervals</span><span class="p">,</span> <span class="n">newInterval</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">lower_start</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
          <span class="k">if</span> <span class="n">upper_end</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[</span><span class="n">newInterval</span><span class="p">]</span>
          <span class="k">if</span> <span class="n">newInterval</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">intervals</span><span class="p">[</span><span class="n">upper_end</span><span class="p">][</span><span class="mi">0</span><span class="p">]:</span>
                <span class="k">return</span> <span class="p">[[</span><span class="n">newInterval</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">max</span><span class="p">(</span><span class="n">newInterval</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">intervals</span><span class="p">[</span><span class="n">upper_end</span><span class="p">][</span><span class="mi">1</span><span class="p">])]]</span> <span class="o">+</span> <span class="n">intervals</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
          <span class="k">else</span><span class="p">:</span>
              <span class="k">return</span> <span class="p">[</span><span class="n">newInterval</span><span class="p">]</span> <span class="o">+</span> <span class="n">intervals</span><span class="p">[</span><span class="n">upper_end</span><span class="p">:]</span>
        <span class="k">if</span> <span class="n">newInterval</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">intervals</span><span class="p">[</span><span class="n">lower_start</span><span class="p">][</span><span class="mi">1</span><span class="p">]:</span>
            <span class="k">if</span> <span class="n">upper_end</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
              <span class="k">return</span> <span class="n">intervals</span><span class="p">[:</span><span class="n">lower_start</span><span class="p">]</span> <span class="o">+</span> <span class="p">[[</span><span class="n">intervals</span><span class="p">[</span><span class="n">lower_start</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">newInterval</span><span class="p">[</span><span class="mi">1</span><span class="p">]]]</span>
            <span class="k">if</span> <span class="n">newInterval</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">intervals</span><span class="p">[</span><span class="n">upper_end</span><span class="p">][</span><span class="mi">0</span><span class="p">]:</span>
                <span class="k">return</span> <span class="n">intervals</span><span class="p">[:</span><span class="n">lower_start</span><span class="p">]</span> <span class="o">+</span> <span class="p">[[</span><span class="n">intervals</span><span class="p">[</span><span class="n">lower_start</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">intervals</span><span class="p">[</span><span class="n">upper_end</span><span class="p">][</span><span class="mi">1</span><span class="p">]]]</span> <span class="o">+</span> <span class="n">intervals</span><span class="p">[</span><span class="n">upper_end</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">intervals</span><span class="p">[:</span><span class="n">lower_start</span><span class="p">]</span> <span class="o">+</span> <span class="p">[[</span><span class="n">intervals</span><span class="p">[</span><span class="n">lower_start</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">newInterval</span><span class="p">[</span><span class="mi">1</span><span class="p">]]]</span> <span class="o">+</span> <span class="n">intervals</span><span class="p">[</span><span class="n">upper_end</span><span class="p">:]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">upper_end</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
              <span class="k">return</span> <span class="n">intervals</span><span class="p">[:</span><span class="n">lower_start</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="n">newInterval</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">newInterval</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">intervals</span><span class="p">[</span><span class="n">upper_end</span><span class="p">][</span><span class="mi">0</span><span class="p">]:</span>
                <span class="k">return</span> <span class="n">intervals</span><span class="p">[:</span><span class="n">lower_start</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="p">[[</span><span class="n">newInterval</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">intervals</span><span class="p">[</span><span class="n">upper_end</span><span class="p">][</span><span class="mi">1</span><span class="p">]]]</span> <span class="o">+</span> <span class="n">intervals</span><span class="p">[</span><span class="n">upper_end</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">intervals</span><span class="p">[:</span><span class="n">lower_start</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="n">newInterval</span><span class="p">]</span> <span class="o">+</span> <span class="n">intervals</span><span class="p">[</span><span class="n">upper_end</span><span class="p">:]</span>


    <span class="k">def</span><span class="w"> </span><span class="nf">find_position</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">intervals</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]],</span> <span class="n">newInterval</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">index</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
      <span class="k">if</span> <span class="n">newInterval</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">intervals</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">index</span><span class="p">]:</span>
        <span class="k">return</span> <span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
      <span class="k">if</span> <span class="n">newInterval</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">intervals</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">index</span><span class="p">]:</span>
        <span class="k">return</span> <span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">intervals</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span>

      <span class="n">lower</span> <span class="o">=</span> <span class="mi">0</span>
      <span class="n">upper</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">intervals</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
      <span class="n">mid</span> <span class="o">=</span> <span class="p">(</span><span class="n">upper</span> <span class="o">+</span> <span class="n">lower</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span>
      <span class="k">while</span> <span class="n">upper</span> <span class="o">!=</span> <span class="n">lower</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:</span>
          <span class="k">if</span> <span class="n">intervals</span><span class="p">[</span><span class="n">mid</span><span class="p">][</span><span class="n">index</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">newInterval</span><span class="p">[</span><span class="n">index</span><span class="p">]:</span>
              <span class="n">lower</span> <span class="o">=</span> <span class="n">mid</span>
          <span class="k">else</span><span class="p">:</span>
              <span class="n">upper</span> <span class="o">=</span> <span class="n">mid</span>
          <span class="n">mid</span> <span class="o">=</span> <span class="p">(</span><span class="n">lower</span> <span class="o">+</span> <span class="n">upper</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span>
      <span class="k">return</span> <span class="p">[</span><span class="n">lower</span><span class="p">,</span> <span class="n">upper</span><span class="p">]</span>
</code></pre></div>
Search in Rotated Sorted Array (Leetcode: #33)
<div class="highlight"><pre><span></span><code><span class="c1">## find the first number in nums that is smaller than target</span>
<span class="c1">## edge case:</span>
<span class="c1">##   nums=[3, 5], target = 1</span>
<span class="k">def</span><span class="w"> </span><span class="nf">binaryFind_num_0</span><span class="p">(</span><span class="n">nums</span><span class="p">,</span> <span class="n">target</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">nums</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span>

    <span class="n">l</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">r</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="n">mid</span> <span class="o">=</span> <span class="p">(</span><span class="n">l</span> <span class="o">+</span> <span class="n">r</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span>  
    <span class="n">ans</span> <span class="o">=</span> <span class="n">mid</span>
    <span class="k">while</span> <span class="n">l</span> <span class="o">&lt;=</span> <span class="n">r</span><span class="p">:</span>
        <span class="c1"># mid is on the left half</span>
        <span class="k">if</span> <span class="n">nums</span><span class="p">[</span><span class="n">mid</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">target</span><span class="p">:</span>
            <span class="n">l</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">+</span> <span class="mi">1</span>

        <span class="c1"># mid is on the right half</span>
        <span class="k">elif</span> <span class="n">nums</span><span class="p">[</span><span class="n">mid</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">target</span><span class="p">:</span>
            <span class="n">r</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">-</span> <span class="mi">1</span>

        <span class="k">if</span> <span class="n">mid</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">&gt;=</span><span class="mi">0</span> <span class="ow">and</span> <span class="n">nums</span><span class="p">[</span><span class="n">mid</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">nums</span><span class="p">[</span><span class="n">mid</span><span class="p">]:</span>
            <span class="n">ans</span> <span class="o">=</span> <span class="n">mid</span>
            <span class="k">break</span>
        <span class="n">mid</span> <span class="o">=</span> <span class="p">(</span><span class="n">l</span> <span class="o">+</span> <span class="n">r</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span>
    <span class="k">return</span> <span class="n">ans</span>


<span class="k">def</span><span class="w"> </span><span class="nf">binaryFind</span><span class="p">(</span><span class="n">nums</span><span class="p">,</span> <span class="n">target</span><span class="p">):</span>
    <span class="n">l</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">r</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="n">ans</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span>
    <span class="k">while</span> <span class="n">l</span> <span class="o">&lt;=</span> <span class="n">r</span><span class="p">:</span>
        <span class="n">mid</span> <span class="o">=</span> <span class="p">(</span><span class="n">l</span> <span class="o">+</span> <span class="n">r</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span>
        <span class="k">if</span> <span class="n">nums</span><span class="p">[</span><span class="n">mid</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">target</span><span class="p">:</span>
            <span class="n">r</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">-</span> <span class="mi">1</span>
            <span class="n">ans</span> <span class="o">=</span> <span class="n">mid</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">l</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="n">ans</span>  

<span class="k">class</span><span class="w"> </span><span class="nc">Solution</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">search</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nums</span><span class="p">,</span> <span class="n">target</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">nums</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
            <span class="n">num_0_pos</span> <span class="o">=</span> <span class="n">binaryFind_num_0</span><span class="p">(</span><span class="n">nums</span><span class="p">[:</span><span class="nb">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">],</span> <span class="n">nums</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">target</span> <span class="o">==</span> <span class="n">nums</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
                <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
            <span class="k">elif</span> <span class="n">target</span> <span class="o">&gt;</span> <span class="n">nums</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
                <span class="n">target_pos</span> <span class="o">=</span> <span class="n">binaryFind</span><span class="p">(</span><span class="n">nums</span><span class="p">[:</span><span class="n">num_0_pos</span><span class="p">],</span> <span class="n">target</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">target_pos</span> <span class="k">if</span> <span class="n">target_pos</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span> <span class="ow">and</span> \
                    <span class="n">nums</span><span class="p">[</span><span class="n">target_pos</span><span class="p">]</span> <span class="o">==</span> <span class="n">target</span> <span class="k">else</span> <span class="o">-</span><span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">target_pos</span> <span class="o">=</span> <span class="n">binaryFind</span><span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="n">num_0_pos</span><span class="p">:],</span> <span class="n">target</span><span class="p">)</span> <span class="o">+</span> <span class="n">num_0_pos</span>
                <span class="k">return</span> <span class="n">target_pos</span> <span class="k">if</span>  <span class="n">target_pos</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span> <span class="ow">and</span> \
                    <span class="n">nums</span><span class="p">[</span><span class="n">target_pos</span><span class="p">]</span> <span class="o">==</span> <span class="n">target</span> <span class="k">else</span> <span class="o">-</span><span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">target_pos</span> <span class="o">=</span> <span class="n">binaryFind</span><span class="p">(</span><span class="n">nums</span><span class="p">,</span> <span class="n">target</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">target_pos</span> <span class="k">if</span> <span class="n">target_pos</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span> <span class="ow">and</span> \
                <span class="n">nums</span><span class="p">[</span><span class="n">target_pos</span><span class="p">]</span> <span class="o">==</span> <span class="n">target</span> <span class="k">else</span> <span class="o">-</span><span class="mi">1</span>  

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;__main__&quot;</span><span class="p">:</span>
    <span class="n">nums</span> <span class="o">=</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">target</span> <span class="o">=</span> <span class="mi">5</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">Solution</span><span class="p">()</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">nums</span><span class="p">,</span> <span class="n">target</span><span class="p">))</span>
</code></pre></div></p>
<h2 id="2">2. 滑动窗口<a class="headerlink" href="#2" title="Permanent link">&para;</a></h2>
<p><strong>题目:</strong></p>
<ul>
<li>leetcode #3</li>
<li>Permutation in String, leetcode #567 / Find All Anagrams in a String, leetcode #438</li>
<li>Minimum Window Substring， leetcode #76</li>
<li>Max Consecutives one III, leetcode #1004</li>
</ul>
<p><strong>思想:</strong></p>
<ol>
<li>准备两个指针，一个指向窗口左端叫head, 一个指向窗口右端叫tail</li>
<li>准备一个集合，用于装窗口中的所有元素</li>
<li>不断移动尾指针，一旦尾指针指向的元素出现在集合中；先确定该元素在窗口的位置，然后将head移动到该位置的右侧,并将集合里start移动时指向的元素删除, 同时更新尾指针指向元素的最新窗口位置</li>
</ol>
<div class="highlight"><pre><span></span><code><span class="kn">from</span><span class="w"> </span><span class="nn">collections</span><span class="w"> </span><span class="kn">import</span> <span class="n">defaultdict</span>
<span class="k">def</span><span class="w"> </span><span class="nf">solution</span><span class="p">(</span><span class="n">A</span><span class="p">:</span> <span class="n">List</span><span class="p">):</span>
    <span class="n">head</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">tail</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">windowSet</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="k">lambda</span><span class="p">:</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> 
    <span class="c1"># key stores the element inside the window, value stores its index in A</span>
    <span class="c1"># if the element is not inside the window, its value is -1 </span>

    <span class="k">while</span> <span class="n">tail</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">A</span><span class="p">):</span>

        <span class="k">if</span> <span class="n">windowSet</span><span class="p">[</span><span class="n">A</span><span class="p">[</span><span class="n">tail</span><span class="p">]]</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">location</span> <span class="o">=</span> <span class="n">windowSet</span><span class="p">[</span><span class="n">A</span><span class="p">[</span><span class="n">tail</span><span class="p">]]</span>
            <span class="k">while</span> <span class="n">head</span> <span class="o">&lt;</span> <span class="n">location</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">windowSet</span><span class="p">[</span><span class="n">head</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="n">head</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">windowSet</span><span class="p">[</span><span class="n">A</span><span class="p">[</span><span class="n">tail</span><span class="p">]]</span> <span class="o">=</span> <span class="n">tail</span>
        <span class="n">tail</span> <span class="o">+=</span> <span class="mi">1</span>
</code></pre></div>
<h2 id="3-graph">3. Graph<a class="headerlink" href="#3-graph" title="Permanent link">&para;</a></h2>
<ul>
<li>DFS:<ul>
<li>detect cycle<ul>
<li>Leetcode #207</li>
</ul>
</li>
</ul>
</li>
<li>BFS:<ul>
<li>level traversal</li>
</ul>
</li>
<li>topological sort</li>
<li>Kruskal &amp; Prim algo(Subgraph tree that connects all vertices and with min weight)</li>
<li>Single-source shortest path</li>
</ul>
<p>Runtime:
BFS/DFS    &lt; Dijkstra           &lt;  Bellman
O(V + E)       O((V + E) logV)</p>
<h3 id="31-dfs">3.1 DFS<a class="headerlink" href="#31-dfs" title="Permanent link">&para;</a></h3>
<p>Template: (Runtime: O(V + E))
<div class="highlight"><pre><span></span><code><span class="kn">from</span><span class="w"> </span><span class="nn">collections</span><span class="w"> </span><span class="kn">import</span> <span class="n">defaultdict</span>
<span class="k">def</span><span class="w"> </span><span class="nf">dfs</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">r</span><span class="p">):</span>
    <span class="n">stack</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="c1"># store the node and its child node index, return value in base case</span>
    <span class="n">stack</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">r</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">acc</span><span class="p">))</span> 
    <span class="n">vertexState</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="k">lambda</span> <span class="p">:</span><span class="mi">0</span><span class="p">)</span> 
    
    <span class="c1"># represent the return result of next recursive call</span>
    <span class="n">last_recur_ret</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">while</span> <span class="n">stack</span><span class="p">:</span>
        <span class="n">v</span><span class="p">,</span> <span class="n">curr_child_index</span> <span class="o">=</span> <span class="n">stack</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> 
        
        <span class="c1"># code block that is executed before recursive call</span>
        <span class="c1"># if last_recur_ret is None:</span>
            <span class="c1"># ....</span>
        <span class="c1"># code block that is executed after recursive call</span>
        <span class="k">if</span> <span class="n">last_recur_ret</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># perform operations on last recursive call result</span>
            <span class="c1"># to have a branch that is done after the first recurse call:</span>
            <span class="c1"># if stack[-1][2] == acc:</span>
            <span class="c1">#    ....</span>
            <span class="n">stack</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">fn</span><span class="p">(</span><span class="n">stack</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">2</span><span class="p">],</span>  <span class="n">last_recur_ret</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">last_recur_ret</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">if</span> <span class="n">vertexState</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">vertexState</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
            
        <span class="k">if</span> <span class="n">curr_child_index</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">graph</span><span class="p">[</span><span class="n">v</span><span class="p">]):</span>
            <span class="k">if</span> <span class="n">vertexState</span><span class="p">[</span><span class="n">graph</span><span class="p">[</span><span class="n">v</span><span class="p">][</span><span class="n">curr_child_index</span><span class="p">]]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">stack</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">curr_child_index</span> <span class="o">+</span> <span class="mi">1</span>
                <span class="n">stack</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">graph</span><span class="p">[</span><span class="n">v</span><span class="p">][</span><span class="n">curr_child_index</span><span class="p">],</span> <span class="mi">0</span><span class="p">))</span>
                <span class="k">continue</span>

        <span class="n">vertexState</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span>
              
        <span class="n">last_recur_ret</span> <span class="o">=</span> <span class="n">stack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
   <span class="k">return</span> <span class="n">last_recur_ret</span>
</code></pre></div></p>
<h4 id="311-detect-cycle">3.1.1 Detect Cycle<a class="headerlink" href="#311-detect-cycle" title="Permanent link">&para;</a></h4>
<p><strong>思路:</strong></p>
<ol>
<li>
<p>每次进入recursive call前，将curr_node作为parent node pass进下一个recursive call, 在下次recursive call中先检查neighbour是否为parent, 如果不是，再检查其status是否是1，如果是，直接return True表示有cycle
题:</p>
</li>
<li>
<p>leetcode: #207</p>
</li>
</ol>
<h3 id="32-bfs">3.2 BFS<a class="headerlink" href="#32-bfs" title="Permanent link">&para;</a></h3>
<p>Runtime: O(V + E)</p>
<div class="tabbed-set tabbed-alternate" data-tabs="2:1"><input checked="checked" id="__tabbed_2_1" name="__tabbed_2" type="radio" /><div class="tabbed-labels"><label for="__tabbed_2_1">Python</label></div>
<div class="tabbed-content">
<div class="tabbed-block">
<div class="highlight"><pre><span></span><code><span class="kn">from</span><span class="w"> </span><span class="nn">collections</span><span class="w"> </span><span class="kn">import</span> <span class="n">deque</span><span class="p">,</span> <span class="n">defaultdict</span>
<span class="k">def</span><span class="w"> </span><span class="nf">bfs</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">v</span><span class="p">):</span>
    <span class="n">q</span> <span class="o">=</span> <span class="n">deque</span><span class="p">([])</span>
    <span class="n">q</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>

    <span class="n">visited</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="k">lambda</span> <span class="p">:</span> <span class="kc">False</span><span class="p">)</span>
    <span class="n">visited</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="k">while</span> <span class="n">q</span><span class="p">:</span>
        <span class="n">v</span> <span class="o">=</span> <span class="n">q</span><span class="o">.</span><span class="n">popleft</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">neighbour</span> <span class="ow">in</span> <span class="n">G</span><span class="p">[</span><span class="n">v</span><span class="p">]:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">visited</span><span class="p">[</span><span class="n">neighbour</span><span class="p">]:</span>
                <span class="n">q</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">neighbour</span><span class="p">)</span>
                <span class="n">visited</span><span class="p">[</span><span class="n">neighbour</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
</code></pre></div>
</div>
</div>
</div>
<h4 id="321-level-order-traversal">3.2.1 level order traversal<a class="headerlink" href="#321-level-order-traversal" title="Permanent link">&para;</a></h4>
<div class="highlight"><pre><span></span><code><span class="kn">from</span><span class="w"> </span><span class="nn">collections</span><span class="w"> </span><span class="kn">import</span> <span class="n">deque</span><span class="p">,</span> <span class="n">defaultdict</span>
<span class="k">def</span><span class="w"> </span><span class="nf">bfs</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">v</span><span class="p">):</span>
    <span class="n">q</span> <span class="o">=</span> <span class="n">deque</span><span class="p">([])</span>
    <span class="n">q</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>

    <span class="n">visited</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="k">lambda</span> <span class="p">:</span> <span class="kc">False</span><span class="p">)</span>
    <span class="n">visited</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="k">while</span> <span class="n">q</span><span class="p">:</span>
        <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">q</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
            <span class="n">v</span> <span class="o">=</span> <span class="n">q</span><span class="o">.</span><span class="n">popleft</span><span class="p">():</span>
            <span class="c1"># code block 1:</span>
                <span class="c1"># ...</span>
            <span class="k">for</span> <span class="n">neighbour</span> <span class="ow">in</span> <span class="n">G</span><span class="p">[</span><span class="n">v</span><span class="p">]:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">visited</span><span class="p">[</span><span class="n">neighbour</span><span class="p">]:</span>
                    <span class="n">visited</span><span class="p">[</span><span class="n">neighbour</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
                    <span class="n">q</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">neighbour</span><span class="p">)</span>
</code></pre></div>
<ul>
<li>Binary Tree ZigZag Level order traversal(Leetcode: #103)</li>
<li>Populating Next Right Pointers in Each Node（Leetcode: #116)</li>
</ul>
<h4 id="322-shortest-path">3.2.2 Shortest path<a class="headerlink" href="#322-shortest-path" title="Permanent link">&para;</a></h4>
<p>题:</p>
<ul>
<li>单词接龙, leetcode #127</li>
<li>Sliding Puzzle, leetcode #773</li>
</ul>
<h3 id="33-single-source-shortest-path">3.3 Single-source shortest path<a class="headerlink" href="#33-single-source-shortest-path" title="Permanent link">&para;</a></h3>
<p>What is the problem:</p>
<blockquote>
<p>Given a graph and a pair of vertices (u, v), we want to find the path from u to v s.t the sum of weights from u to v is minimized</p>
</blockquote>
<p>Restriction for Bellman-Ford:</p>
<ul>
<li>
<p>The graph cannot contain a cycle where the sum of the edges of the cycle is negative and can be reached from starting vertex s
Practice:</p>
</li>
<li>
<p>find shortest path on directed/undirected graph
Bellman-Ford <code>O(VE)</code>:
<div class="highlight"><pre><span></span><code><span class="kn">from</span><span class="w"> </span><span class="nn">collections</span><span class="w"> </span><span class="kn">import</span> <span class="n">defaultdict</span>
<span class="k">def</span><span class="w"> </span><span class="nf">relax</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">short_path</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">short_path</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">+</span> <span class="n">w</span> <span class="o">&lt;</span> <span class="n">short_path</span><span class="p">[</span><span class="n">v</span><span class="p">]:</span>
        <span class="n">short_path</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="n">short_path</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">+</span> <span class="n">w</span>
        <span class="k">return</span> <span class="kc">True</span>
    <span class="k">return</span> <span class="kc">False</span>

<span class="k">def</span><span class="w"> </span><span class="nf">BellmanFord</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">s</span><span class="p">):</span>
    <span class="c1"># Initialize single source and edges</span>
    <span class="n">shortest_path</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="k">lambda</span> <span class="p">:</span><span class="nb">float</span><span class="p">(</span><span class="s2">&quot;inf&quot;</span><span class="p">))</span>
    <span class="n">shortest_path</span><span class="p">[</span><span class="n">s</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="c1"># relax each edge of u</span>
    <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">G</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">u</span> <span class="ow">in</span> <span class="n">G</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">v</span><span class="p">,</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">G</span><span class="p">[</span><span class="n">u</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">shortest_path</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">!=</span> <span class="nb">float</span><span class="p">(</span><span class="s2">&quot;inf&quot;</span><span class="p">):</span>
                    <span class="n">relax</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">shortest_path</span><span class="p">)</span>

    <span class="c1"># detect negative cycle</span>
    <span class="k">for</span> <span class="n">u</span> <span class="ow">in</span> <span class="n">G</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">v</span><span class="p">,</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">G</span><span class="p">[</span><span class="n">u</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">shortest_path</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">!=</span> <span class="nb">float</span><span class="p">(</span><span class="s2">&quot;inf&quot;</span><span class="p">)</span> <span class="ow">and</span> \
            <span class="n">shortest_path</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">+</span> <span class="n">w</span> <span class="o">&lt;</span> <span class="n">shortest_path</span><span class="p">[</span><span class="n">v</span><span class="p">]:</span>
                <span class="k">return</span> <span class="kc">False</span>

    <span class="k">return</span> <span class="kc">True</span>         
</code></pre></div></p>
</li>
</ul>
<p>Restriction for Dijkstra:</p>
<ul>
<li>The graph cannot have negative weight edges
Practice</li>
<li>find shortest path on directed/undirected graph
Dijkstra's algorithm(<code>O((V+E)logV)</code>):
<div class="highlight"><pre><span></span><code><span class="kn">from</span><span class="w"> </span><span class="nn">collections</span><span class="w"> </span><span class="kn">import</span> <span class="n">defaultdict</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">heapq</span><span class="w"> </span><span class="kn">import</span> <span class="n">heappop</span>
<span class="k">def</span><span class="w"> </span><span class="nf">relax</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">short_path</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">short_path</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">+</span> <span class="n">w</span> <span class="o">&lt;</span> <span class="n">short_path</span><span class="p">[</span><span class="n">v</span><span class="p">]:</span>
        <span class="n">short_path</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="n">short_path</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">+</span> <span class="n">w</span>
        <span class="k">return</span> <span class="kc">True</span>
    <span class="k">return</span> <span class="kc">False</span>

<span class="k">def</span><span class="w"> </span><span class="nf">dijkstra</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">s</span><span class="p">):</span>
    <span class="c1"># stores the nodes on the shortest path</span>
    <span class="c1"># for each node as key, store it distance from s</span>
    <span class="n">shortest_path</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="k">lambda</span> <span class="p">:</span> <span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="s2">&quot;inf&quot;</span><span class="p">)))</span>
    <span class="n">shortest_path</span><span class="p">[</span><span class="n">s</span><span class="p">]</span><span class="o">=</span> <span class="mi">0</span>
    <span class="n">Q</span> <span class="o">=</span> <span class="p">[(</span><span class="mi">0</span><span class="p">,</span> <span class="n">s</span><span class="p">)]</span>
    <span class="k">while</span> <span class="n">Q</span><span class="p">:</span>
        <span class="n">curr_distance</span><span class="p">,</span> <span class="n">u</span> <span class="o">=</span> <span class="n">heappop</span><span class="p">(</span><span class="n">Q</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">curr_distance</span> <span class="o">&gt;</span> <span class="n">short_path</span><span class="p">[</span><span class="n">u</span><span class="p">]:</span>
            <span class="k">continue</span>

        <span class="c1"># relax each edge of u</span>
        <span class="k">for</span> <span class="n">v</span><span class="p">,</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">G</span><span class="p">[</span><span class="n">u</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">relax</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">shortest_path</span><span class="p">):</span>
                <span class="n">heapq</span><span class="o">.</span><span class="n">heappush</span><span class="p">(</span><span class="n">Q</span><span class="p">,</span> <span class="p">(</span><span class="n">shortest_path</span><span class="p">[</span><span class="n">v</span><span class="p">],</span> <span class="n">v</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">shortest_path</span>
</code></pre></div></li>
</ul>
<p>题:</p>
<ul>
<li>Cheapest flights within K stops (leetcode #787)</li>
<li>Network Delay time(leetcode #743)</li>
</ul>
<h3 id="34-all-pairs-shortest-path">3.4 All-pairs shortest path<a class="headerlink" href="#34-all-pairs-shortest-path" title="Permanent link">&para;</a></h3>
<p>Floyd-Warshal(<span class="arithmatex">\(O(V^3)\)</span>)
- When to use: when |E| &gt; <span class="arithmatex">\(|V|^2\)</span><br />
- restriction: the graph cannot contain negative cycles (where the sum of the edges in a cycle is negative)
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">FloydWarshal</span><span class="p">(</span><span class="n">G</span><span class="p">):</span>
    <span class="c1"># G must be a |V|x|V| matrix with each entry as the weight value;</span>
    <span class="c1"># Otherwise, we will have to loop through each edge of G to construct D,</span>
    <span class="c1"># which is not allowed</span>
    <span class="n">num_vertices</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">graph</span><span class="p">)</span>  
    <span class="n">dist</span> <span class="o">=</span> <span class="p">[</span><span class="n">row</span><span class="p">[:]</span> <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">graph</span><span class="p">]</span> <span class="c1"># Create a copy of the graph  </span>

    <span class="c1"># Iterate through all possible intermediate vertices &#39;k&#39;  </span>
    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_vertices</span><span class="p">):</span>  
        <span class="c1"># Iterate through all possible source vertices &#39;i&#39;  </span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_vertices</span><span class="p">):</span>  
            <span class="c1"># Iterate through all possible destination vertices &#39;j&#39;  </span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_vertices</span><span class="p">):</span>  
            <span class="c1"># If vertex &#39;k&#39; is on the shortest path from &#39;i&#39; to &#39;j&#39;,  </span>
            <span class="c1"># then update the distance  </span>
                <span class="k">if</span> <span class="n">dist</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">k</span><span class="p">]</span> <span class="o">!=</span> <span class="nb">float</span><span class="p">(</span><span class="s1">&#39;inf&#39;</span><span class="p">)</span> <span class="ow">and</span> \
                <span class="n">dist</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">!=</span> <span class="nb">float</span><span class="p">(</span><span class="s1">&#39;inf&#39;</span><span class="p">):</span>  
                    <span class="n">dist</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">dist</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">],</span> <span class="n">dist</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">k</span><span class="p">]</span> <span class="o">+</span> <span class="n">dist</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">j</span><span class="p">])</span>  
    <span class="k">return</span> <span class="n">dist</span>
</code></pre></div></p>
<h3 id="35-mst">3.5 MST<a class="headerlink" href="#35-mst" title="Permanent link">&para;</a></h3>
<p>What is MST</p>
<blockquote>
<p>an acyclic tree whose:
-  edge set is a subset of G
- connect all vertices
- sum of weights of all edges are minimized</p>
</blockquote>
<p>Kruskal's algorithm<code>O(E lg(V))</code>
<div class="highlight"><pre><span></span><code><span class="c1">## class DisjointSet:</span>

<span class="k">def</span><span class="w"> </span><span class="nf">createMST</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">w</span><span class="p">):</span>
    <span class="n">A</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>

    <span class="n">ds</span> <span class="o">=</span> <span class="n">DisjointSet</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
        <span class="n">ds</span><span class="o">.</span><span class="n">makeSet</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>

    <span class="c1"># sort the edges of G.E into nondecreasing order by weight w</span>
    <span class="n">E</span> <span class="o">=</span> <span class="n">sort</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>

    <span class="k">for</span> <span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span> <span class="ow">in</span> <span class="n">E</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">ds</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="n">u</span><span class="p">)</span> <span class="o">!=</span> <span class="n">ds</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="n">v</span><span class="p">):</span>
            <span class="n">A</span><span class="o">.</span><span class="n">add</span><span class="p">((</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">))</span>
            <span class="n">ds</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">A</span>
</code></pre></div></p>
<p>Prim's algorithm: <code>O(E + V lg(V))</code>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">prim</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">start_vertex</span><span class="p">):</span>
    <span class="c1"># graph example: {&#39;A&#39;: {&#39;B&#39;: 1, &#39;C&#39;: 4}, &#39;B&#39;: {&#39;A&#39;: 1, &#39;C&#39;: 2, &#39;D&#39;: 5}}</span>
    <span class="n">mst</span> <span class="o">=</span> <span class="p">[]</span> <span class="c1"># Stores the edges of the Minimum Spanning Tree  </span>
    <span class="n">visited</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span> <span class="c1"># Keeps track of visited vertices  </span>

    <span class="c1"># Priority queue (min-heap) to store edges, ordered by weight  </span>
    <span class="c1"># Format: (weight, from_vertex, to_vertex)  </span>
    <span class="n">edges</span> <span class="o">=</span> <span class="p">[]</span>  

    <span class="c1"># Start with the initial vertex  </span>
    <span class="n">visited</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">start_vertex</span><span class="p">)</span>  
    <span class="k">for</span> <span class="n">neighbor</span><span class="p">,</span> <span class="n">weight</span> <span class="ow">in</span> <span class="n">graph</span><span class="p">[</span><span class="n">start_vertex</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>  
        <span class="n">heapq</span><span class="o">.</span><span class="n">heappush</span><span class="p">(</span><span class="n">edges</span><span class="p">,</span> <span class="p">(</span><span class="n">weight</span><span class="p">,</span> <span class="n">start_vertex</span><span class="p">,</span> <span class="n">neighbor</span><span class="p">))</span>  

    <span class="k">while</span> <span class="n">edges</span><span class="p">:</span> 
        <span class="c1"># Get the edge with the minimum weight </span>
        <span class="n">weight</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span> <span class="o">=</span> <span class="n">heapq</span><span class="o">.</span><span class="n">heappop</span><span class="p">(</span><span class="n">edges</span><span class="p">)</span>  

        <span class="k">if</span> <span class="n">v</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">visited</span><span class="p">:</span>  
            <span class="n">visited</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>  
            <span class="n">mst</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">weight</span><span class="p">))</span>  

        <span class="c1"># Add all edges connected to the newly visited vertex to the heap </span>
        <span class="k">for</span> <span class="n">neighbor_of_v</span><span class="p">,</span> <span class="n">weight_to_neighbor</span> <span class="ow">in</span> <span class="n">graph</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>  
            <span class="k">if</span> <span class="n">neighbor_of_v</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">visited</span><span class="p">:</span>  
                <span class="n">heapq</span><span class="o">.</span><span class="n">heappush</span><span class="p">(</span><span class="n">edges</span><span class="p">,</span> \
                <span class="p">(</span><span class="n">weight_to_neighbor</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">neighbor_of_v</span><span class="p">))</span>  

    <span class="k">return</span> <span class="n">mst</span>
</code></pre></div></p>
<h2 id="4-greedy-choiice">4. Greedy choiice<a class="headerlink" href="#4-greedy-choiice" title="Permanent link">&para;</a></h2>
<ul>
<li>Server selection(snow flake OA)<blockquote>
<p>把n本书分给k个人复印，想要使每个人复印的总时间的最大值最小化。很明显是一个求最优解的问题，很自然的想到用贪心的思想。因为每本书都是没有差异的，所以可以依次贪心的为每一本书选择k个人中的最优人选。 令times[]表示每个人复印一本书的时间，sum[]表示每个人复印所花的总时间。若此时在判断把第 i 本书给哪个人复印，此时前 (i - 1) 本书被复印的最短时间是minSum。实现过程如下：若把第 i 本书给第 j 个人复印，这时第 j 个人所花的总时间 sum[j] + times[j] ，若这个总时间不大于minSum，说明对答案没影响，那么选其中任意一种即可，结束循环人选； 若把第 i 本书给第 j 个人复印，这时第 j 个人所花的总时间 sum[j] + times[j] ，若这个总时间大于minSum，说明答案会变大，那么我们继续判断下一个人选，选择令答案增加的最少的一种情况；每次选择结束后都要更新一次答案，minSum = max(Minsum, sum[被选择的人]) 。</p>
</blockquote>
</li>
</ul>
<p><div class="highlight"><pre><span></span><code>sort time from low to high
sum = []
append (lowest time, index of it in times) to sum
let s be the set that contains people are copying at the same time
add the people who has the loest to sum
let s_prime be the complimentary set
for each i = 1 to n:
    find the lowest time tuple in sum
    put the people from the tuple from s to s_prime
    find people with the lowest time in s_prime
    if that people&#39;s time plus the time in tuple is greater than some people p1,
        add p1&#39;s time and p1 to sum
    else:
        modify the tuple&#39;s time and index to that people
</code></pre></div>
- 递增的三元子序列(Leetcode #334)
    - Longest increasing subsequence(Leetcode #300, general version of #334)
    - <a href="https://leetcode.cn/problems/russian-doll-envelopes/">Russian Doll Envelopes, leetcode #354</a>
- 任务调度器 Leetcode #621
- jump game II, leetcode #45 / jump game, leetcode #55</p>
<p><strong>递增的三元子序列(Leetcode #334)</strong>
- 思路: loop一边array, 每loop一个元素<code>array[i]</code>, 维护两个变量: small和mid, small为<code>array[0..i]</code>最小的element, mid为<code>array[0..i]</code>中大于<code>small</code>最小的element
<div class="highlight"><pre><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">Solution</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">increasingTriplet</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nums</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :type nums: List[int]</span>
<span class="sd">        :rtype: bool</span>
<span class="sd">        &quot;&quot;&quot;</span>        
        <span class="n">small</span> <span class="o">=</span> <span class="n">nums</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">mid</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="s2">&quot;inf&quot;</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">small</span><span class="p">:</span>
                <span class="n">small</span> <span class="o">=</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="k">elif</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">small</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">mid</span><span class="p">:</span>
                    <span class="n">mid</span> <span class="o">=</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="k">elif</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">mid</span><span class="p">:</span>
                    <span class="k">return</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="kc">False</span>
</code></pre></div></p>
<h2 id="5-dp">5. DP<a class="headerlink" href="#5-dp" title="Permanent link">&para;</a></h2>
<ul>
<li>lintcode 151</li>
<li>lintcode1850</li>
<li>task scheduling(snowflake OA)</li>
<li>Palindrome/substring<ul>
<li>Longest Palindrome substring(Leetcode #5)</li>
</ul>
</li>
<li>House Robber, Leetcode #198</li>
</ul>
<h3 id="51-palindromesubstring">5.1 Palindrome/substring<a class="headerlink" href="#51-palindromesubstring" title="Permanent link">&para;</a></h3>
<p>思路: 准备一个dp的dictionary, dp以(i, j)为key, 其中(i, j)表示<code>s[i..j]</code>, <code>dp[(i, j)]</code> 表示<code>s[i..j]</code>满足某种条件为True/False</p>
<p>Longest Palindrome substring(Leetcode #5)
(Note: Leetcode sometimes only accept bottom-to-top DP, and does not accept top-to-bottom recursive DP, leetcode #5 is an example)</p>
<p>bottom-to-top DP soln:
<div class="highlight"><pre><span></span><code><span class="kn">from</span><span class="w"> </span><span class="nn">collections</span><span class="w"> </span><span class="kn">import</span> <span class="n">defaultdict</span>
<span class="k">class</span><span class="w"> </span><span class="nc">Solution</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">longestPalindrome</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">):</span>       
        <span class="n">dp</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="k">lambda</span> <span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">acc</span> <span class="o">=</span> <span class="n">s</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)):</span>
            <span class="n">dp</span><span class="p">[(</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="p">)]</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>

            <span class="n">dp</span><span class="p">[(</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)]</span> <span class="o">=</span> <span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">s</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>

            <span class="k">if</span> <span class="n">dp</span><span class="p">[(</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)]</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">acc</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">acc</span> <span class="o">=</span> <span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">:</span><span class="n">i</span><span class="o">+</span><span class="mi">2</span><span class="p">]</span>


        <span class="k">for</span> <span class="n">L</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)):</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="o">-</span> <span class="n">L</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="n">s</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="n">L</span><span class="p">]:</span>
                    <span class="n">dp</span><span class="p">[(</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span> <span class="o">+</span> <span class="n">L</span><span class="p">)]</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">dp</span><span class="p">[(</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span> <span class="o">+</span> <span class="n">L</span><span class="p">)]</span> <span class="o">=</span> <span class="n">dp</span><span class="p">[(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">i</span> <span class="o">+</span> <span class="n">L</span> <span class="o">-</span><span class="mi">1</span><span class="p">)]</span>

                    <span class="k">if</span> <span class="n">dp</span><span class="p">[(</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span> <span class="o">+</span> <span class="n">L</span><span class="p">)]</span> <span class="o">==</span> <span class="kc">True</span> <span class="ow">and</span> <span class="n">L</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">acc</span><span class="p">):</span>
                        <span class="n">acc</span> <span class="o">=</span> <span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">:</span><span class="n">i</span> <span class="o">+</span> <span class="n">L</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">acc</span>
</code></pre></div></p>
<p>Top-to-bottom recursive soln(does not work for large input):
<div class="highlight"><pre><span></span><code><span class="kn">from</span><span class="w"> </span><span class="nn">collections</span><span class="w"> </span><span class="kn">import</span> <span class="n">defaultdict</span>
<span class="k">def</span><span class="w"> </span><span class="nf">dp_recursive_helper</span><span class="p">(</span><span class="n">dp</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="n">j</span><span class="p">:</span>
        <span class="n">dp</span><span class="p">[(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)]</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="kc">True</span>

    <span class="k">if</span> <span class="n">j</span> <span class="o">==</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">dp</span><span class="p">[(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)]</span> <span class="o">=</span> <span class="mi">1</span> <span class="k">if</span> <span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">s</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="k">else</span> <span class="mi">0</span>

    <span class="k">if</span> <span class="n">dp</span><span class="p">[(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)]</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">dp</span><span class="p">[(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)]</span>

    <span class="k">if</span> <span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="n">s</span><span class="p">[</span><span class="n">j</span><span class="p">]:</span>
        <span class="n">dp</span><span class="p">[(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)]</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">dp</span><span class="p">[(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)]</span> <span class="o">=</span> <span class="n">dp_recursive_helper</span><span class="p">(</span><span class="n">dp</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>


    <span class="k">return</span> <span class="n">dp</span><span class="p">[(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)]</span>

<span class="k">class</span><span class="w"> </span><span class="nc">Solution</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">longestPalindrome</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">):</span> 
        <span class="n">dp</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="k">lambda</span> <span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
                <span class="n">is_palindrome</span> <span class="o">=</span> <span class="n">dp_recursive_helper</span><span class="p">(</span><span class="n">dp</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span>

                <span class="k">if</span> <span class="n">is_palindrome</span><span class="p">:</span>

                    <span class="k">if</span> <span class="n">j</span> <span class="o">-</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">acc</span><span class="p">):</span>

                        <span class="n">acc</span> <span class="o">=</span> <span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">:</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">acc</span>              
</code></pre></div></p>
<h3 id="52-other">5.2 Other<a class="headerlink" href="#52-other" title="Permanent link">&para;</a></h3>
<ul>
<li>Coin Change(Leetcode #522)
总结: dp中, 假设一个range为<span class="arithmatex">\(c * 10^4\)</span> 到<span class="arithmatex">\(10^5\)</span>, 可以作为dp的一个for loop一个一个循环, 如下example, 因而，永远要检查input size
<div class="highlight"><pre><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">Solution</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">coinChange</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">coins</span><span class="p">,</span> <span class="n">amount</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :type coins: List[int]</span>
<span class="sd">        :type amount: int</span>
<span class="sd">        :rtype: int</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">dp</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="k">lambda</span> <span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>

        <span class="n">dp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">for</span> <span class="n">coin</span> <span class="ow">in</span> <span class="n">coins</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">coin</span><span class="p">,</span> <span class="n">amount</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">dp</span><span class="p">[</span><span class="n">x</span> <span class="o">-</span> <span class="n">coin</span><span class="p">]</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">dp</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                        <span class="n">dp</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="n">dp</span><span class="p">[</span><span class="n">x</span> <span class="o">-</span> <span class="n">coin</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">dp</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">dp</span><span class="p">[</span><span class="n">x</span><span class="p">],</span> <span class="n">dp</span><span class="p">[</span><span class="n">x</span> <span class="o">-</span> <span class="n">coin</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">dp</span><span class="p">[</span><span class="n">amount</span><span class="p">]</span>
</code></pre></div></li>
</ul>
<h2 id="6-backtracing">6. backtracing<a class="headerlink" href="#6-backtracing" title="Permanent link">&para;</a></h2>
<p>https://leetcode.cn/problems/combination-sum/solutions/14697/hui-su-suan-fa-jian-zhi-python-dai-ma-java-dai-m-2/</p>
<p>图中为啥4分支在搜索的时候不在考虑2:</p>
<p>WTS: 对所有层，假设第一个使用的candidate是x, 假设第二个使用的candidate是y, target是z, 那么y分支下所有包含x的路径都被x分支包含(即搜y分支不需要考虑x)</p>
<ul>
<li>
<p>假设y分支不存在包含x的路径，那么我们也不需要考虑x, 这种case结束</p>
</li>
<li>
<p>假设y分支存在包含x的路径，也就是说z &gt; y + x, 那么x分支下也存在一条路路径包含y, x分支下的y路径的第一个节点(z - x-y)下包含了所有总和为(z - x -y)的路径也就和y分支下包含x的路径节点重合</p>
</li>
</ul>
<h2 id="7-prefix-sum-array">7. Prefix sum &amp; array<a class="headerlink" href="#7-prefix-sum-array" title="Permanent link">&para;</a></h2>
<p>什么叫前缀和数组:</p>
<blockquote>
<p>给一个数组a = [a1, a2, ... aN], a的前缀和数组是 a = [a1, a1 + a2, a1+a2+a3, ... (a1 + a2 +...aN)]</p>
</blockquote>
<ul>
<li>House Robber, Leetcode #198</li>
<li>Maximum Subarray, leetcode #53 </li>
<li>Maximum Product Subarray, leetcode #152</li>
</ul>
<h2 id="8">8. 双指针<a class="headerlink" href="#8" title="Permanent link">&para;</a></h2>
<h3 id="81">8.1 前后指针<a class="headerlink" href="#81" title="Permanent link">&para;</a></h3>
<ul>
<li>three sum(K-sum)</li>
</ul>
<div class="tabbed-set tabbed-alternate" data-tabs="3:2"><input checked="checked" id="__tabbed_3_1" name="__tabbed_3" type="radio" /><input id="__tabbed_3_2" name="__tabbed_3" type="radio" /><div class="tabbed-labels"><label for="__tabbed_3_1">Python</label><label for="__tabbed_3_2">Javascript</label></div>
<div class="tabbed-content">
<div class="tabbed-block">
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">twoSum</span><span class="p">(</span><span class="n">nums</span><span class="p">,</span> <span class="n">startIndex</span><span class="p">,</span> <span class="n">endIndex</span><span class="p">,</span> <span class="n">target</span><span class="p">):</span>
    <span class="n">phead</span> <span class="o">=</span> <span class="n">startIndex</span>
    <span class="n">ptail</span> <span class="o">=</span> <span class="n">endIndex</span>
    <span class="n">acc</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">while</span> <span class="n">phead</span> <span class="o">&lt;</span> <span class="n">ptail</span><span class="p">:</span>
        <span class="n">curr_sum</span> <span class="o">=</span> <span class="n">nums</span><span class="p">[</span><span class="n">phead</span><span class="p">]</span> <span class="o">+</span> <span class="n">nums</span><span class="p">[</span><span class="n">ptail</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">curr_sum</span> <span class="o">&gt;</span> <span class="n">target</span><span class="p">:</span>
            <span class="n">ptail</span> <span class="o">-=</span> <span class="mi">1</span>
        <span class="k">elif</span> <span class="n">curr_sum</span> <span class="o">&lt;</span> <span class="n">target</span><span class="p">:</span>
            <span class="n">phead</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">acc</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">nums</span><span class="p">[</span><span class="n">phead</span><span class="p">],</span> <span class="n">nums</span><span class="p">[</span><span class="n">ptail</span><span class="p">]])</span>

            <span class="k">while</span> <span class="n">phead</span> <span class="o">&lt;</span> <span class="n">ptail</span> <span class="ow">and</span> <span class="n">nums</span><span class="p">[</span><span class="n">phead</span><span class="p">]</span> <span class="o">==</span> <span class="n">nums</span><span class="p">[</span><span class="n">phead</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]:</span>
                <span class="n">phead</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">phead</span> <span class="o">+=</span> <span class="mi">1</span>

            <span class="k">while</span> <span class="n">phead</span> <span class="o">&lt;</span> <span class="n">ptail</span> <span class="ow">and</span> <span class="n">nums</span><span class="p">[</span><span class="n">ptail</span><span class="p">]</span> <span class="o">==</span> <span class="n">nums</span><span class="p">[</span><span class="n">ptail</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]:</span>
                <span class="n">ptail</span> <span class="o">-=</span> <span class="mi">1</span> 
            <span class="n">ptail</span> <span class="o">-=</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="n">acc</span>


<span class="k">class</span><span class="w"> </span><span class="nc">Solution</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">threeSum</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nums</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :type nums: List[int]</span>
<span class="sd">        :rtype: List[List[int]]</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">nums</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
        <span class="n">acc</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span> <span class="o">-</span> <span class="mi">2</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]:</span>
                <span class="n">curr_pairs</span> <span class="o">=</span> <span class="n">twoSum</span><span class="p">(</span><span class="n">nums</span><span class="p">,</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                <span class="k">for</span> <span class="n">curr_pair</span> <span class="ow">in</span> <span class="n">curr_pairs</span><span class="p">:</span>
                    <span class="n">acc</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">curr_pair</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">curr_pair</span><span class="p">[</span><span class="mi">1</span><span class="p">]])</span>
        <span class="k">return</span> <span class="n">acc</span>
</code></pre></div>
</div>
<div class="tabbed-block">
<div class="highlight"><pre><span></span><code><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">()</span>
</code></pre></div>
</div>
</div>
</div>
<h3 id="82">8.2 快慢指针<a class="headerlink" href="#82" title="Permanent link">&para;</a></h3>
<p>思路: 有四种思路；
- 第一种，维护两个指针，第二个指针在第一个指针k个位置之后作为快指针，同时移动两指针,快指针到达末尾后，满指针到达末尾第k个位置; 
    - <a href="https://leetcode.com/problems/remove-nth-node-from-end-of-list/">Remove Nth Node From End of List, leetcode #19</a>
- 第二种, 维护两个指针, 第二个指针的step为第一个指针移动step的两倍, 同时移动两指针, 当第二个指针到达末尾时, 第一个指针到达中点
    - <a href="https://leetcode.com/problems/middle-of-the-linked-list/">Middle of the Linked List, leetcode #876</a>
    - 判断环起点([[Algorithm#11.3 寻找环起点]]), leetcode #141, leetcode #142
- 第三种, 维护两个指针，快指针照常每个iteration前进一个元素, 满指针在每个iteration根据特定条件前进一个元素
- 第四种, 滑动窗口
- Others:
    - Gas staation, leetcode #134</p>
<p>模板:</p>
<ul>
<li>第二张快慢:
    -
    ```Python
    class Solution:
    def middleNode(self, head: Optional[ListNode]) -&gt; Optional[ListNode]:
        p1 = head
        p2 = p1</li>
</ul>
<p>while p2 and p2.next:
            p1 = p1.next
            p2 = p2.next.next
        return p1
    ```
- 第三种:
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">fn</span><span class="p">(</span><span class="n">arr</span><span class="p">):</span>
    <span class="n">p_slow</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">p_fast</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">while</span> <span class="n">p_fast</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">:</span>
        <span class="c1"># arr[p_slow] satisfies certain condition, we move p_slow</span>
        <span class="k">if</span> <span class="n">condition</span><span class="p">(</span><span class="n">arr</span><span class="p">[</span><span class="n">p_slow</span><span class="p">]):</span>
            <span class="n">p_slow</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">p_fast</span> <span class="o">+=</span> <span class="mi">1</span>
</code></pre></div></p>
<h2 id="9-tree">9. Tree<a class="headerlink" href="#9-tree" title="Permanent link">&para;</a></h2>
<h3 id="91-traversal">9.1  traversal<a class="headerlink" href="#91-traversal" title="Permanent link">&para;</a></h3>
<ul>
<li>Construct Binary Tree from Preorder and Inorder Traversal(Leetcode: #105)</li>
</ul>
<h3 id="92-avl-tree">9.2 AVL Tree<a class="headerlink" href="#92-avl-tree" title="Permanent link">&para;</a></h3>
<ul>
<li>Convert sorted array to AVL tree(Leetcode #108):
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">helper</span><span class="p">(</span><span class="n">nums</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">i</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">None</span>

    <span class="n">mid</span> <span class="o">=</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="n">j</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span>
    <span class="n">root</span> <span class="o">=</span> <span class="n">TreeNode</span><span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="n">mid</span><span class="p">])</span>
    <span class="n">root</span><span class="o">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">helper</span><span class="p">(</span><span class="n">nums</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">mid</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">root</span><span class="o">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">helper</span><span class="p">(</span><span class="n">nums</span><span class="p">,</span> <span class="n">mid</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span>
    <span class="n">root</span><span class="o">.</span><span class="n">height</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">if</span> <span class="n">root</span><span class="o">.</span><span class="n">left</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">root</span><span class="o">.</span><span class="n">height</span> <span class="o">=</span> <span class="n">root</span><span class="o">.</span><span class="n">left</span><span class="o">.</span><span class="n">height</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="k">if</span> <span class="n">root</span><span class="o">.</span><span class="n">right</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">root</span><span class="o">.</span><span class="n">height</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">root</span><span class="o">.</span><span class="n">height</span><span class="p">,</span> <span class="n">root</span><span class="o">.</span><span class="n">right</span><span class="o">.</span><span class="n">height</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">root</span>

<span class="k">def</span><span class="w"> </span><span class="nf">sortedArrayToBST</span><span class="p">(</span><span class="n">nums</span><span class="p">):</span>
    <span class="n">helper</span><span class="p">(</span><span class="n">nums</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
</code></pre></div></li>
<li>convert binary tree to AVL tree(Leetcode #1382):
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">solution</span><span class="p">(</span><span class="n">root</span><span class="p">):</span>
    <span class="c1"># step 1: perform in order traversal to the BST to convert it into sorted array</span>
    <span class="c1"># use the above template to convert sorted array into AVL tree</span>
</code></pre></div></li>
<li>AVL Tree implementation</li>
</ul>
<div class="tabbed-set tabbed-alternate" data-tabs="4:1"><input checked="checked" id="__tabbed_4_1" name="__tabbed_4" type="radio" /><div class="tabbed-labels"><label for="__tabbed_4_1">Python</label></div>
<div class="tabbed-content">
<div class="tabbed-block">
<div class="highlight"><pre><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">TreeNode</span><span class="p">:</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">val</span> <span class="o">=</span> <span class="n">val</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">left</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">right</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">height</span> <span class="o">=</span> <span class="mi">1</span>

<span class="k">class</span><span class="w"> </span><span class="nc">AVLTree</span><span class="p">:</span>
    <span class="c1"># keyFunc takes a, b as inputs</span>
    <span class="c1"># keyFunc returns 1 if a &gt; b, 0 if a == b, -1 if a &lt; b</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">keyFunc</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">keyFunc</span> <span class="o">=</span> <span class="n">keyFunc</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">root</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">search</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="n">curr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">root</span>
        <span class="k">while</span> <span class="n">curr</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">keyFunc</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">curr</span><span class="o">.</span><span class="n">val</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">keyFunc</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">curr</span><span class="o">.</span><span class="n">val</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">curr</span> <span class="o">=</span> <span class="n">curr</span><span class="o">.</span><span class="n">left</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">curr</span> <span class="o">=</span> <span class="n">curr</span><span class="o">.</span><span class="n">right</span>
        <span class="k">return</span> <span class="n">curr</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">insert</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">root</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">root</span> <span class="o">=</span> <span class="n">TreeNode</span><span class="p">(</span><span class="n">val</span><span class="o">=</span><span class="n">value</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">root</span>

        <span class="n">curr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">root</span>
        <span class="n">stack</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">while</span> <span class="n">curr</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">keyFunc</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">curr</span><span class="o">.</span><span class="n">val</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">stack</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">curr</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
                <span class="n">curr</span> <span class="o">=</span> <span class="n">curr</span><span class="o">.</span><span class="n">right</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">stack</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">curr</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
                <span class="n">curr</span> <span class="o">=</span> <span class="n">curr</span><span class="o">.</span><span class="n">left</span>

        <span class="n">leaf</span><span class="p">,</span> <span class="n">side</span> <span class="o">=</span> <span class="n">stack</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">side</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">leaf</span><span class="o">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">TreeNode</span><span class="p">(</span><span class="n">val</span><span class="o">=</span><span class="n">value</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">leaf</span><span class="o">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">TreeNode</span><span class="p">(</span><span class="n">val</span><span class="o">=</span><span class="n">value</span><span class="p">)</span>

        <span class="n">lastBalancedNode</span> <span class="o">=</span> <span class="n">balanceTree</span><span class="p">(</span><span class="n">stack</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">lastBalanceNode</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">root</span> <span class="o">=</span> <span class="n">lastBalanceNode</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">root</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">delete</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">root</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>

        <span class="n">curr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">root</span>
        <span class="n">stack</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">while</span> <span class="n">curr</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">keyFunc</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">curr</span><span class="o">.</span><span class="n">value</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">stack</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">curr</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
                <span class="n">curr</span> <span class="o">=</span> <span class="n">curr</span><span class="o">.</span><span class="n">right</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">keyFunc</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">curr</span><span class="o">.</span><span class="n">value</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">stack</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">curr</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
                <span class="n">curr</span> <span class="o">=</span> <span class="n">curr</span><span class="o">.</span><span class="n">left</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">curr</span><span class="o">.</span><span class="n">left</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">curr</span><span class="o">.</span><span class="n">right</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">break</span>
                <span class="c1"># when the deleted node has both children</span>
                <span class="c1"># replace deleted node with the leftmost leaf in </span>
                <span class="c1"># right subtree</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">successor</span> <span class="o">=</span> <span class="n">curr</span><span class="o">.</span><span class="n">right</span>
                    <span class="k">while</span> <span class="n">successor</span><span class="o">.</span><span class="n">left</span><span class="p">:</span>
                        <span class="n">successor</span> <span class="o">=</span> <span class="n">successor</span><span class="o">.</span><span class="n">left</span>
                    <span class="n">curr</span><span class="o">.</span><span class="n">val</span><span class="p">,</span> <span class="n">success</span><span class="o">.</span><span class="n">val</span> <span class="o">=</span> <span class="n">successor</span><span class="o">.</span><span class="n">val</span><span class="p">,</span> <span class="n">curr</span><span class="o">.</span><span class="n">val</span>
                    <span class="n">stack</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">curr</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
                    <span class="n">curr</span> <span class="o">=</span> <span class="n">curr</span><span class="o">.</span><span class="n">right</span>

        <span class="c1"># case: value does not exist in tree</span>
        <span class="k">if</span> <span class="n">curr</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>

        <span class="c1"># case: when value is at the root and root only has one child</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">stack</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">root</span> <span class="o">=</span> <span class="n">curr</span><span class="o">.</span><span class="n">right</span> <span class="k">if</span> <span class="n">curr</span><span class="o">.</span><span class="n">left</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">curr</span><span class="o">.</span><span class="n">left</span>
            <span class="k">return</span> <span class="n">curr</span>

        <span class="n">parent</span><span class="p">,</span> <span class="n">side</span> <span class="o">=</span> <span class="n">stack</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">side</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">parent</span><span class="o">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">curr</span><span class="o">.</span><span class="n">right</span> <span class="k">if</span> <span class="n">curr</span><span class="o">.</span><span class="n">left</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">curr</span><span class="o">.</span><span class="n">left</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">parent</span><span class="o">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">curr</span><span class="o">.</span><span class="n">right</span> <span class="k">if</span> <span class="n">curr</span><span class="o">.</span><span class="n">left</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">curr</span><span class="o">.</span><span class="n">right</span>

        <span class="n">lastBalancedNode</span> <span class="o">=</span> <span class="n">balanceTree</span><span class="p">(</span><span class="n">stack</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">lastBalancedNode</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">root</span> <span class="o">=</span> <span class="n">lastBalancedNode</span>

        <span class="k">return</span> <span class="n">curr</span>



<span class="k">def</span><span class="w"> </span><span class="nf">getHeight</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">TreeNode</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">x</span><span class="o">.</span><span class="n">height</span> <span class="k">if</span> <span class="n">x</span> <span class="k">else</span> <span class="mi">0</span>

<span class="k">def</span><span class="w"> </span><span class="nf">leftRotate</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">TreeNode</span><span class="p">):</span>
    <span class="n">R</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">right</span>
    <span class="n">RL</span> <span class="o">=</span> <span class="n">R</span><span class="o">.</span><span class="n">left</span>

    <span class="c1"># Makes x becomes the root of R&#39;s left subtree</span>
    <span class="n">x</span><span class="o">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">RL</span>
    <span class="n">R</span><span class="o">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">x</span>

    <span class="c1"># adjust height of R and x</span>
    <span class="n">x</span><span class="o">.</span><span class="n">height</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="nb">max</span><span class="p">(</span><span class="n">getHeight</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">left</span><span class="p">),</span> <span class="n">getHeight</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">right</span><span class="p">))</span>
    <span class="n">R</span><span class="o">.</span><span class="n">height</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="nb">max</span><span class="p">(</span><span class="n">getHeight</span><span class="p">(</span><span class="n">R</span><span class="o">.</span><span class="n">left</span><span class="p">),</span> <span class="n">getHeight</span><span class="p">(</span><span class="n">R</span><span class="o">.</span><span class="n">right</span><span class="p">))</span>
    
    <span class="k">return</span> <span class="n">R</span>
    
<span class="k">def</span><span class="w"> </span><span class="nf">rightRotate</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">TreeNode</span><span class="p">):</span>
    <span class="n">L</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">left</span>
    <span class="n">LR</span> <span class="o">=</span> <span class="n">L</span><span class="o">.</span><span class="n">right</span>

    <span class="n">x</span><span class="o">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">LR</span>
    <span class="n">L</span><span class="o">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">x</span> 

    <span class="n">x</span><span class="o">.</span><span class="n">height</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="nb">max</span><span class="p">(</span><span class="n">getHeight</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">left</span><span class="p">),</span> <span class="n">getHeight</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">right</span><span class="p">))</span>
    <span class="n">L</span><span class="o">.</span><span class="n">height</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="nb">max</span><span class="p">(</span><span class="n">getHeight</span><span class="p">(</span><span class="n">L</span><span class="o">.</span><span class="n">left</span><span class="p">),</span> <span class="n">getHeight</span><span class="p">(</span><span class="n">L</span><span class="o">.</span><span class="n">right</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">L</span>

<span class="k">def</span><span class="w"> </span><span class="nf">balance</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">TreeNode</span><span class="p">):</span>
    <span class="n">balance</span> <span class="o">=</span> <span class="n">getHeight</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">left</span><span class="p">)</span> <span class="o">-</span> <span class="n">getHeight</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">right</span><span class="p">)</span>
    <span class="n">L</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">left</span>
    <span class="n">R</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">right</span>

    <span class="k">if</span> <span class="n">balance</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">leftbalance</span> <span class="o">=</span> <span class="n">getHeight</span><span class="p">(</span><span class="n">L</span><span class="o">.</span><span class="n">left</span><span class="p">)</span> <span class="o">-</span> <span class="n">getHeight</span><span class="p">(</span><span class="n">L</span><span class="o">.</span><span class="n">right</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">leftbalance</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">left_Rotate</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> 
        <span class="k">else</span><span class="p">:</span>
            <span class="n">x</span><span class="o">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">left_Rotate</span><span class="p">(</span><span class="n">L</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">right_Rotate</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">balance</span> <span class="o">&lt;</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
        <span class="n">rightbalance</span> <span class="o">=</span> <span class="n">getHeight</span><span class="p">(</span><span class="n">R</span><span class="o">.</span><span class="n">left</span><span class="p">)</span> <span class="o">-</span> <span class="n">getHeight</span><span class="p">(</span><span class="n">R</span><span class="o">.</span><span class="n">right</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">rightbalance</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">left_Rotate</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">x</span><span class="o">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">right_Rotate</span><span class="p">(</span><span class="n">R</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">left_Rotate</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">x</span>

<span class="k">def</span><span class="w"> </span><span class="nf">balanceTree</span><span class="p">(</span><span class="n">stack</span><span class="p">):</span>
    <span class="n">prev</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">while</span> <span class="n">stack</span><span class="p">:</span>
        <span class="n">curr</span><span class="p">,</span> <span class="n">side</span> <span class="o">=</span> <span class="n">stack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span> 

        <span class="k">if</span> <span class="n">prev</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">side</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">curr</span><span class="o">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">prev</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">curr</span><span class="o">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">prev</span>
            <span class="n">prev</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="n">curr</span><span class="o">.</span><span class="n">height</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="nb">max</span><span class="p">(</span><span class="n">getHeight</span><span class="p">(</span><span class="n">curr</span><span class="o">.</span><span class="n">left</span><span class="p">),</span> <span class="n">getHeight</span><span class="p">(</span><span class="n">curr</span><span class="o">.</span><span class="n">right</span><span class="p">))</span>
        
        <span class="n">heightdiff</span> <span class="o">=</span> <span class="n">getHeight</span><span class="p">(</span><span class="n">curr</span><span class="o">.</span><span class="n">left</span><span class="p">)</span> <span class="o">-</span> <span class="n">getHeight</span><span class="p">(</span><span class="n">curr</span><span class="o">.</span><span class="n">right</span><span class="p">)</span>  
        <span class="k">if</span> <span class="n">heightdiff</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="ow">or</span> <span class="n">heightdiff</span> <span class="o">&lt;</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="n">prev</span> <span class="o">=</span> <span class="n">balance</span><span class="p">(</span><span class="n">curr</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">prev</span>
</code></pre></div>
</div>
</div>
</div>
<h2 id="10-heap">10. Heap<a class="headerlink" href="#10-heap" title="Permanent link">&para;</a></h2>
<p>Heap operation templates:</p>
<div class="tabbed-set tabbed-alternate" data-tabs="5:1"><input checked="checked" id="__tabbed_5_1" name="__tabbed_5" type="radio" /><div class="tabbed-labels"><label for="__tabbed_5_1">Python</label></div>
<div class="tabbed-content">
<div class="tabbed-block">
<div class="highlight"><pre><span></span><code><span class="c1"># swap larger element between parents and one of its children from ith node to the leaf, below is max-heap</span>
<span class="c1"># Effect: makes arr[i:n] a heap, also called heapify</span>
<span class="k">def</span><span class="w"> </span><span class="nf">sift_down</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">i</span><span class="p">):</span>
    <span class="n">curr_parent</span> <span class="o">=</span> <span class="n">i</span>  

    <span class="k">while</span> <span class="n">curr_parent</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">:</span>
        <span class="n">next_parent</span> <span class="o">=</span> <span class="n">curr_parent</span>
        <span class="n">left_child</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">curr_parent</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="n">right_child</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">curr_parent</span> <span class="o">+</span> <span class="mi">2</span>

        <span class="k">if</span> <span class="n">left_child</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="ow">and</span> <span class="n">arr</span><span class="p">[</span><span class="n">left_child</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">arr</span><span class="p">[</span><span class="n">next_parent</span><span class="p">]:</span>
            <span class="n">next_parent</span> <span class="o">=</span> <span class="n">left_child</span>

        <span class="k">if</span> <span class="n">right_child</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="ow">and</span> <span class="n">arr</span><span class="p">[</span><span class="n">right_child</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">arr</span><span class="p">[</span><span class="n">next_parent</span><span class="p">]:</span>
            <span class="n">next_parent</span> <span class="o">=</span> <span class="n">right_child</span>

        <span class="k">if</span> <span class="n">next_parent</span> <span class="o">!=</span> <span class="n">curr_parent</span><span class="p">:</span>
            <span class="n">arr</span><span class="p">[</span><span class="n">curr_parent</span><span class="p">],</span> <span class="n">arr</span><span class="p">[</span><span class="n">next_parent</span><span class="p">]</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="n">next_parent</span><span class="p">],</span> <span class="n">arr</span><span class="p">[</span><span class="n">curr_parent</span><span class="p">]</span>
            <span class="n">curr_parent</span> <span class="o">=</span> <span class="n">next_parent</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">break</span>

<span class="k">def</span><span class="w"> </span><span class="nf">sift_up</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">i</span><span class="p">):</span>
    <span class="n">curr_i</span> <span class="o">=</span> <span class="n">i</span>  
    <span class="k">while</span> <span class="n">curr_i</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">parent_i</span> <span class="o">=</span> <span class="p">(</span><span class="n">curr_i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">arr</span><span class="p">[</span><span class="n">curr_i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">arr</span><span class="p">[</span><span class="n">parent_i</span><span class="p">]:</span>
            <span class="n">arr</span><span class="p">[</span><span class="n">curr_i</span><span class="p">],</span> <span class="n">arr</span><span class="p">[</span><span class="n">parent_i</span><span class="p">]</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="n">parent_i</span><span class="p">],</span> <span class="n">arr</span><span class="p">[</span><span class="n">curr_i</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">break</span>

<span class="k">def</span><span class="w"> </span><span class="nf">heappush</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">item</span><span class="p">):</span>
    <span class="n">arr</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>
    <span class="n">sift_up</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>

<span class="k">def</span><span class="w"> </span><span class="nf">heappop</span><span class="p">(</span><span class="n">arr</span><span class="p">):</span>
    <span class="n">tailItem</span> <span class="o">=</span> <span class="n">arr</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">heap</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">tailItem</span> 
    <span class="n">headItem</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="n">arr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">tailItem</span>
    <span class="n">sift_down</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">arr</span><span class="p">),</span> <span class="mi">0</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">headItem</span>

<span class="k">def</span><span class="w"> </span><span class="nf">heappushpop</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">item</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">item</span>
    <span class="k">if</span> <span class="n">arr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">item</span><span class="p">:</span>   
        <span class="k">return</span> <span class="n">heappoppush</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">item</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">item</span>

<span class="k">def</span><span class="w"> </span><span class="nf">heappoppush</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">item</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">Error</span><span class="p">(</span><span class="s2">&quot;err&quot;</span><span class="p">)</span>
    <span class="c1"># replace the head of the heap with new item, then heapify</span>
    <span class="n">headItem</span><span class="p">,</span> <span class="n">arr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">item</span>
    <span class="n">sift_down</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">arr</span><span class="p">),</span> <span class="mi">0</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">headItem</span>
</code></pre></div>
</div>
</div>
</div>
<ul>
<li>heapSort<ul>
<li>Non-inplace</li>
</ul>
</li>
</ul>
<div class="tabbed-set tabbed-alternate" data-tabs="6:2"><input checked="checked" id="__tabbed_6_1" name="__tabbed_6" type="radio" /><input id="__tabbed_6_2" name="__tabbed_6" type="radio" /><div class="tabbed-labels"><label for="__tabbed_6_1">python</label><label for="__tabbed_6_2">Javascript</label></div>
<div class="tabbed-content">
<div class="tabbed-block">
<div class="highlight"><pre><span></span><code><span class="kn">from</span><span class="w"> </span><span class="nn">heapq</span><span class="w"> </span><span class="kn">import</span> <span class="n">heappush</span><span class="p">,</span> <span class="n">heappop</span>
<span class="k">def</span><span class="w"> </span><span class="nf">sort</span><span class="p">(</span><span class="n">nums</span><span class="p">):</span>
    <span class="n">h</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">nums</span><span class="p">:</span>
        <span class="n">heappush</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>

    <span class="k">return</span> <span class="p">[</span><span class="n">heappop</span><span class="p">(</span><span class="n">h</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">h</span><span class="p">))]</span>
</code></pre></div>
</div>
<div class="tabbed-block">
<div class="highlight"><pre><span></span><code>
</code></pre></div>
</div>
</div>
</div>
<ul>
<li>Inplace sort:</li>
</ul>
<div class="tabbed-set tabbed-alternate" data-tabs="7:1"><input checked="checked" id="__tabbed_7_1" name="__tabbed_7" type="radio" /><div class="tabbed-labels"><label for="__tabbed_7_1">python</label></div>
<div class="tabbed-content">
<div class="tabbed-block">
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">sort</span><span class="p">(</span><span class="n">nums</span><span class="p">):</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span> 
    <span class="c1"># build max heap that extract max key</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span> <span class="o">//</span> <span class="mi">2</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
        <span class="n">heapify</span><span class="p">(</span><span class="n">nums</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
        <span class="c1"># moves the largest element to the end of the array</span>
        <span class="n">nums</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">nums</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="c1"># Keeps arr[:n-1] (excluding the last element) a heap</span>
        <span class="n">heapify</span><span class="p">(</span><span class="n">nums</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
</code></pre></div>
</div>
</div>
</div>
<ul>
<li>K items comparison(Min-heap):<ul>
<li>Merge K sorted List(Leetcode #23)</li>
</ul>
</li>
<li>sort Interval<ul>
<li>252 Meeting Rooms](https://leetcode.com/problems/meeting-rooms/)</li>
<li><a href="https://leetcode.com/problems/meeting-rooms-ii/">253 Meeting Rooms II</a></li>
<li><a href="https://leetcode.com/problems/non-overlapping-intervals/">435 Non-overlapping Intervals</a></li>
</ul>
</li>
</ul>
<h2 id="11-linkedlist">11. LinkedList<a class="headerlink" href="#11-linkedlist" title="Permanent link">&para;</a></h2>
<ul>
<li>合并LinkedList</li>
</ul>
<h3 id="111-linkedlist">11.1 合并LinkedList<a class="headerlink" href="#111-linkedlist" title="Permanent link">&para;</a></h3>
<ul>
<li>
<p>思路:
<img alt="" src="../images/1.gif" /></p>
</li>
<li>
<p><a href="https://leetcode.cn/problems/merge-two-sorted-lists/">合并两个有序链表, leetcode #21</a>
<div class="highlight"><pre><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">mergeTwoLists</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">list1</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ListNode</span><span class="p">],</span> <span class="n">list2</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ListNode</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ListNode</span><span class="p">]:</span>
        <span class="n">acc</span> <span class="o">=</span> <span class="n">ListNode</span><span class="p">()</span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">acc</span>
        <span class="n">p1</span><span class="p">,</span> <span class="n">p2</span> <span class="o">=</span> <span class="n">list1</span><span class="p">,</span> <span class="n">list2</span>

        <span class="k">while</span> <span class="n">p1</span> <span class="ow">and</span> <span class="n">p2</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">p1</span><span class="o">.</span><span class="n">val</span> <span class="o">&lt;=</span> <span class="n">p2</span><span class="o">.</span><span class="n">val</span><span class="p">:</span>                <span class="n">p</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">p1</span>
                <span class="n">p1</span> <span class="o">=</span> <span class="n">p1</span><span class="o">.</span><span class="n">next</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">p</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">p2</span>
                <span class="n">p2</span> <span class="o">=</span> <span class="n">p2</span><span class="o">.</span><span class="n">next</span>
            <span class="n">p</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">next</span>  

        <span class="k">if</span> <span class="n">p1</span><span class="p">:</span>
            <span class="k">while</span> <span class="n">p1</span><span class="p">:</span>
                <span class="n">p</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">p1</span>
                <span class="n">p</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">next</span>
                <span class="n">p1</span> <span class="o">=</span> <span class="n">p1</span><span class="o">.</span><span class="n">next</span>

        <span class="k">if</span> <span class="n">p2</span><span class="p">:</span>
            <span class="k">while</span> <span class="n">p2</span><span class="p">:</span>
                <span class="n">p</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">p2</span>
                <span class="n">p</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">next</span>
                <span class="n">p2</span> <span class="o">=</span> <span class="n">p2</span><span class="o">.</span><span class="n">next</span>
        <span class="k">return</span> <span class="n">acc</span><span class="o">.</span><span class="n">next</span>
</code></pre></div></p>
</li>
<li>
<p><a href="https://leetcode.cn/problems/merge-k-sorted-lists/">合并K个升序链表, leetcode #23</a></p>
<ul>
<li>思路: 有用到heap</li>
</ul>
</li>
</ul>
<h3 id="112-linkedlist">11.2 寻找LinkedList倒数位置或中点<a class="headerlink" href="#112-linkedlist" title="Permanent link">&para;</a></h3>
<h3 id="113">11.3 寻找环起点<a class="headerlink" href="#113" title="Permanent link">&para;</a></h3>
<p><img alt="" src="../images/Pasted%20image%2020250930192654.png" /></p>
<h2 id="12-disjoint-set">12. Disjoint Set<a class="headerlink" href="#12-disjoint-set" title="Permanent link">&para;</a></h2>
<p>Operations:</p>
<ul>
<li>find(<code>O(α(n))</code>)</li>
<li>union(<code>O(α(n))</code>)</li>
<li>makeSet(<code>O(α(n))</code>)
<code>α(n)</code>is the <strong>inverse Ackermann function</strong> (which grows slower than log)</li>
</ul>
<p>Data structure:</p>
<div class="highlight"><pre><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">DisjointSet</span><span class="p">:</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lst</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">parent</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rank</span> <span class="o">=</span> <span class="p">{}</span>  <span class="c1"># the height of each node</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">makeSet</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Add a new element as its own set.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">x</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="n">x</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">rank</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">find</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Find the root of x with path compression&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">x</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">makeSet</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">!=</span> <span class="n">x</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">[</span><span class="n">x</span><span class="p">])</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">[</span><span class="n">x</span><span class="p">]</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">union</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Union the sets containing x and y&quot;&quot;&quot;</span>
        <span class="n">root_x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="n">root_y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">root_x</span> <span class="o">==</span> <span class="n">root_y</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">rank</span><span class="p">[</span><span class="n">root_x</span><span class="p">]</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">rank</span><span class="p">[</span><span class="n">root_y</span><span class="p">]:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">[</span><span class="n">root_x</span><span class="p">]</span> <span class="o">=</span> <span class="n">root_y</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">rank</span><span class="p">[</span><span class="n">root_y</span><span class="p">]</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">rank</span><span class="p">[</span><span class="n">root_x</span><span class="p">]:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">[</span><span class="n">root_y</span><span class="p">]</span> <span class="o">=</span> <span class="n">root_x</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">[</span><span class="n">root_y</span><span class="p">]</span> <span class="o">=</span> <span class="n">root_x</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">rank</span><span class="p">[</span><span class="n">root_x</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>     
</code></pre></div>
<h2 id="13-trie">13. Trie(前缀树)<a class="headerlink" href="#13-trie" title="Permanent link">&para;</a></h2>
<p><strong>题目</strong>: Leetcode #208</p>
<p><strong>应用</strong>: 搜索查询时,搜索引擎通过用户的输入作为前缀从数据库的高频词汇中召回所有以该用户的输入为前缀的词汇</p>
<p>用于存储字符串:</p>
<div class="tabbed-set tabbed-alternate" data-tabs="8:2"><input checked="checked" id="__tabbed_8_1" name="__tabbed_8" type="radio" /><input id="__tabbed_8_2" name="__tabbed_8" type="radio" /><div class="tabbed-labels"><label for="__tabbed_8_1">python</label><label for="__tabbed_8_2">Java</label></div>
<div class="tabbed-content">
<div class="tabbed-block">
<div class="highlight"><pre><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">Trie</span><span class="p">:</span>
    <span class="c1"># 比比较通用的模板 #</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initialize your data structure here.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">child</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">isword</span> <span class="o">=</span> <span class="kc">False</span>  <span class="c1">#表示该Trie node是否为一个字符串的结尾</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">insert</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">word</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Inserts a word into the trie.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">rt</span><span class="o">=</span> <span class="bp">self</span>  <span class="c1">#相当于c++的this指针！！！</span>
        <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">word</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">w</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">child</span><span class="p">:</span>     <span class="c1">#没有，就新建</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">child</span><span class="p">[</span><span class="n">w</span><span class="p">]</span> <span class="o">=</span> <span class="n">Trie</span><span class="p">()</span>
            <span class="n">rt</span> <span class="o">=</span> <span class="n">rt</span><span class="o">.</span><span class="n">child</span><span class="p">[</span><span class="n">w</span><span class="p">]</span>          <span class="c1">#往下走</span>
        <span class="n">rt</span><span class="o">.</span><span class="n">isword</span> <span class="o">=</span> <span class="kc">True</span>        <span class="c1">#标记位</span>


    <span class="k">def</span><span class="w"> </span><span class="nf">search</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">word</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns if the word is in the trie.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">rt</span><span class="o">=</span> <span class="bp">self</span>  <span class="c1">#相当于c++的this指针！！！</span>
        <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">word</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">w</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">rt</span><span class="o">.</span><span class="n">child</span><span class="p">:</span>     <span class="c1">#有字母不在这条path上，断了</span>
                <span class="k">return</span> <span class="kc">False</span>
            <span class="n">rt</span> <span class="o">=</span> <span class="n">rt</span><span class="o">.</span><span class="n">child</span><span class="p">[</span><span class="n">w</span><span class="p">]</span>          <span class="c1">#沿着path往下走</span>
        <span class="k">return</span> <span class="n">rt</span><span class="o">.</span><span class="n">isword</span> <span class="o">==</span> <span class="kc">True</span>    <span class="c1">#看isword位</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">startsWith</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">prefix</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns if there is any word in the trie that starts with the given prefix.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">rt</span> <span class="o">=</span> <span class="bp">self</span>  <span class="c1">#相当于c++的this指针！！！</span>
        <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">prefix</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">w</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">rt</span><span class="o">.</span><span class="n">child</span><span class="p">:</span>     <span class="c1">#path断了</span>
                <span class="k">return</span> <span class="kc">False</span>
            <span class="n">rt</span> <span class="o">=</span> <span class="n">rt</span><span class="o">.</span><span class="n">child</span><span class="p">[</span><span class="n">w</span><span class="p">]</span>
        <span class="k">return</span> <span class="kc">True</span>
</code></pre></div>
</div>
<div class="tabbed-block">
<div class="highlight"><pre><span></span><code>
</code></pre></div>
</div>
</div>
</div>
<h2 id="14-monostack">14. MonoStack<a class="headerlink" href="#14-monostack" title="Permanent link">&para;</a></h2>
<p>https://itnext.io/monotonic-stack-identify-pattern-3da2d491a61e</p>
<p>What is a monoStack:</p>
<blockquote>
<p>A monostack is a stack whose elements are monotonically non-decreasing or non-increasing. The monstack has two operations: pop and push(varied based on the type of monostack) to maintain this property. There are 2 types of mono stack:</p>
<ul>
<li>mono-decreasing:</li>
<li>pop: pop out the item at the top of the stack(tail of the array)</li>
<li>push(item):<ol>
<li>while stack not empty and stack.top &lt; item:</li>
<li>pop(stack.top)</li>
<li>insert(stack, item)</li>
</ol>
</li>
<li>mono-increasing:</li>
<li>pop: pop out the item at the top of the stack</li>
<li>push(item):<ol>
<li>while stack not empty and stack.top &gt; item:</li>
<li>pop(stack.top)</li>
<li>insert(stack, item)</li>
</ol>
</li>
</ul>
</blockquote>
<p>Application of mono-stack:</p>
<ol>
<li>Find Next-Great-Element and Prev-Great-Element of each array element</li>
</ol>
<blockquote>
<p>For mono nondecreasing stack:</p>
<p>we define the following(for each array element <code>arr[i]</code>):</p>
<ul>
<li>Next-Great-Element(arr[i]): the first value that is greater than <code>arr[i]</code> on the right of <code>arr[i]</code> </li>
<li>Prev-Great-Element(arr[i]): the last value that is greater than <code>arr[i]</code> on the left of <code>arr[i]</code></li>
</ul>
<p>We usually load the array content into a mono stack as above by consistently pushing the element of the array. During the push(item), for each element <code>arr[i]</code> that is popped, Next-Great-Element(arr[i]) is the  newly inserted <code>item</code> and Prev-Great-Element(arr[i]) is the element that is before <code>arr[i]</code> in stack(i.e: the stack top after we pop <code>arr[i]</code>). If we need to use Next-Great-Element(arr[i]) or Prev-Great-Element(arr[i]) of each element <code>arr[i]</code> to solve the problem, consider monostack</p>
</blockquote>
<ol>
<li>find the smallest combination of array element in the array</li>
</ol>
<blockquote>
<p>After loading all elements into the stack, the stack exhibits the following property:</p>
<ul>
<li>the array element of the stack is in sequential order, where the i^th^ element of the stack must be before the j^th^ element of the stack in original array if i &lt; j</li>
<li>Among all sub-sequences from the array that is in sequential order, the sequence in the stack has the smallest lexicographical order comparing with any sequence of the same length(smallest lexicographical order refers to "A string <code>a</code> is <strong>lexicographically smaller</strong> than a string <code>b</code> if in the first position where <code>a</code> and <code>b</code> differ, string <code>a</code> has a letter that appears earlier in the alphabet than the corresponding letter in <code>b</code>.If the first <code>min(a.length, b.length)</code> characters do not differ, then the shorter string is the lexicographically smaller one.")</li>
</ul>
<p>Application: leetcode: #316</p>
</blockquote>
<h2 id="15-divide-conquer">15. Divide &amp; Conquer<a class="headerlink" href="#15-divide-conquer" title="Permanent link">&para;</a></h2>
<ul>
<li>Search a 2D Matrix II, leetcode #240</li>
</ul>
<h2 id="16-segment-tree">16. Segment Tree<a class="headerlink" href="#16-segment-tree" title="Permanent link">&para;</a></h2>
<p>why do we need Segment Tree:</p>
<blockquote>
<p>When we want to sum an array, the worst runtime is O(n) and update it, the runtime is O(1)
If we have equal number of two operations, the total runtime is O(n)
However, the update and get sum for a range for segment tree are both <code>O(log n)</code>. A segment tree is an array that exhibits a tree structure</p>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">build</span><span class="p">(</span><span class="n">arr</span><span class="p">):</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>
    <span class="n">tree</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">n</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
        <span class="n">tree</span><span class="p">[</span><span class="n">n</span> <span class="o">+</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
        <span class="n">tree</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">tree</span><span class="p">[</span><span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">tree</span><span class="p">[</span><span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span> <span class="o">|</span> <span class="mi">1</span><span class="p">]</span>

<span class="c1">## n is the length of arr, update arr[p]</span>
<span class="k">def</span><span class="w"> </span><span class="nf">updateTreeNode</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
    <span class="n">i</span> <span class="o">=</span> <span class="n">p</span> <span class="o">+</span> <span class="n">n</span>
    <span class="n">tree</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>

    <span class="k">while</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="c1"># i is odd, then i ^ 1 is even, both i and i ^ 1 are children</span>
        <span class="c1"># i is even, then i ^ 1 is odd, both i and i ^ 1 are children</span>
        <span class="n">tree</span><span class="p">[</span><span class="n">i</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">tree</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">tree</span><span class="p">[</span><span class="n">i</span> <span class="o">^</span> <span class="mi">1</span><span class="p">]</span>
        <span class="n">i</span> <span class="o">&gt;&gt;=</span> <span class="mi">1</span>

<span class="c1">## query the sum on interval [l, r), n is the length of arr</span>
<span class="k">def</span><span class="w"> </span><span class="nf">query</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">):</span>
    <span class="n">res</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">l</span> <span class="o">=</span> <span class="n">start</span> <span class="o">+</span> <span class="n">n</span>
    <span class="n">r</span> <span class="o">=</span> <span class="n">end</span> <span class="o">+</span> <span class="n">n</span>

    <span class="k">while</span> <span class="n">l</span> <span class="o">&lt;</span> <span class="n">r</span><span class="p">:</span>
        <span class="c1"># l is odd, odd position in tree is always the right child of parent</span>
        <span class="c1"># l += 1, l becomes the left child of the next parent</span>
        <span class="k">if</span> <span class="n">l</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">res</span> <span class="o">+=</span> <span class="n">tree</span><span class="p">[</span><span class="n">l</span><span class="p">]</span>
            <span class="n">l</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="c1"># r is odd</span>
        <span class="k">if</span> <span class="n">r</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">r</span> <span class="o">-=</span> <span class="mi">1</span>
            <span class="n">res</span> <span class="o">+=</span> <span class="n">tree</span><span class="p">[</span><span class="n">r</span><span class="p">]</span>
        <span class="n">l</span> <span class="o">&gt;&gt;=</span> <span class="mi">1</span>
        <span class="n">r</span> <span class="o">&gt;&gt;=</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="n">res</span>
</code></pre></div>
<h2 id="17-line-sweep">17. Line sweep<a class="headerlink" href="#17-line-sweep" title="Permanent link">&para;</a></h2>
<p>Intuition: https://www.youtube.com/watch?v=nNtiZM-j3Pk&amp;list=PLubYOWSl9mItBLmB2WiFU0A_WINUSLtGH
code reference: 
- https://www.geeksforgeeks.org/dsa/given-a-set-of-line-segments-find-if-any-two-segments-intersect/
- https://panda-man.medium.com/mastering-efficiency-exploring-line-sweep-algorithm-with-python-673e4522e979</p>
<p>What is the problem:</p>
<blockquote>
<p>Given a set of line segments(e.g: <code>[[x1, y1], [x2, y2]]</code>) which are represented by the x, y coordinates of their endpoints, we want to find the total set of intersection points</p>
</blockquote>
<h3 id="171-cross-product-application">17.1 Cross Product application<a class="headerlink" href="#171-cross-product-application" title="Permanent link">&para;</a></h3>
<p>Computing cross product lies at the heart of many line segments problem. Here are the problems that can be applied:
1. Given 2 directed segments <span class="arithmatex">\(P_0P_1\)</span> and <span class="arithmatex">\(P_0P_2\)</span>, is <span class="arithmatex">\(P_0P_1\)</span> clockwise from <span class="arithmatex">\(P_0P_2\)</span> w.r.t <span class="arithmatex">\(P_0\)</span>?
2. Given <span class="arithmatex">\(P_0P_1\)</span> and point <span class="arithmatex">\(P_2\)</span>, is <span class="arithmatex">\(P_2\)</span> on the left side or right side of <span class="arithmatex">\(P_0P_1\)</span> ?
3. Do <span class="arithmatex">\(P_1P2\)</span> and <span class="arithmatex">\(P_3P_4\)</span> intersect?</p>
<blockquote>
<ol>
<li>Clockwise Problem
We have the following property:
let <span class="arithmatex">\(P_0\)</span> be (0, 0):</li>
<li>if <span class="arithmatex">\(P_1\)</span> X <span class="arithmatex">\(P_2\)</span> &gt; 0,   <span class="arithmatex">\(P_1\)</span> is clockwise from <span class="arithmatex">\(P_2\)</span> w.r.t <span class="arithmatex">\(P_0\)</span></li>
<li>if <span class="arithmatex">\(P_1\)</span> X <span class="arithmatex">\(P_2\)</span> &lt; 0,  <span class="arithmatex">\(P_1\)</span> is counter-clockwise from <span class="arithmatex">\(P_2\)</span> w.r.t <span class="arithmatex">\(P_0\)</span></li>
<li>
<p>if <span class="arithmatex">\(P_1\)</span> X <span class="arithmatex">\(P_2\)</span> = 0, <span class="arithmatex">\(P_1\)</span> is parallel to <span class="arithmatex">\(P_2\)</span></p>
</li>
<li>
<p>Left-side problem
Equivalent to determining angle <span class="arithmatex">\(\angle P_0P_1P_2\)</span> is counter-clockwise or not:
<img alt="" src="../images/Pasted%20image%2020251015202219.png" />
</p>
</li>
<li>
<p>Intersection
To determine intersection, check either of the following:</p>
</li>
<li>both endpoints of <span class="arithmatex">\(P_1P_2\)</span> are on both sides of <span class="arithmatex">\(P_3P_4\)</span> and both endpoints of <span class="arithmatex">\(P_3P_4\)</span> are on both sides of <span class="arithmatex">\(P_1P_2\)</span></li>
<li>an endpoint of one segment lies on the other segment</li>
</ol>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">crossProduct</span><span class="p">(</span><span class="n">v1</span><span class="p">,</span> <span class="n">v2</span><span class="p">):</span>
    <span class="n">x1</span><span class="p">,</span> <span class="n">y1</span> <span class="o">=</span> <span class="n">v1</span>
    <span class="n">x2</span><span class="p">,</span> <span class="n">y2</span> <span class="o">=</span> <span class="n">v2</span>
    <span class="k">return</span> <span class="n">x1</span> <span class="o">*</span> <span class="n">y2</span> <span class="o">-</span> <span class="n">x2</span> <span class="o">*</span> <span class="n">y1</span>

<span class="k">def</span><span class="w"> </span><span class="nf">side</span><span class="p">(</span><span class="n">segment</span><span class="p">,</span> <span class="n">p</span><span class="p">):</span>
    <span class="n">p1</span><span class="p">,</span> <span class="n">p2</span> <span class="o">=</span> <span class="n">segment</span>
    <span class="k">return</span> <span class="n">crossProduct</span><span class="p">(</span><span class="n">p</span> <span class="o">-</span> <span class="n">p1</span><span class="p">,</span> <span class="n">p</span> <span class="o">-</span> <span class="n">p2</span><span class="p">)</span>

<span class="k">def</span><span class="w"> </span><span class="nf">onSegment</span><span class="p">(</span><span class="n">segment</span><span class="p">,</span> <span class="n">p</span><span class="p">):</span>
    <span class="n">p1</span><span class="p">,</span> <span class="n">p2</span> <span class="o">=</span> <span class="n">segment</span>
    <span class="n">x1</span><span class="p">,</span> <span class="n">y1</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">y2</span> <span class="o">=</span> <span class="n">p1</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">p1</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">p2</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">p2</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">p</span>

    <span class="k">return</span> <span class="nb">min</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">x</span> <span class="o">&lt;=</span> <span class="nb">max</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">min</span><span class="p">(</span><span class="n">y1</span><span class="p">,</span> <span class="n">y2</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">y</span> <span class="o">&lt;=</span> <span class="nb">max</span><span class="p">(</span><span class="n">y1</span><span class="p">,</span> <span class="n">y2</span><span class="p">)</span>

<span class="k">def</span><span class="w"> </span><span class="nf">intersection</span><span class="p">(</span><span class="n">P1P2</span><span class="p">,</span> <span class="n">P3P4</span><span class="p">):</span>
    <span class="n">P1</span><span class="p">,</span> <span class="n">P2</span> <span class="o">=</span> <span class="n">P1P2</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">P1P2</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">P3</span><span class="p">,</span> <span class="n">P4</span> <span class="o">=</span> <span class="n">P3P4</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">P3P4</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

    <span class="n">P1_side</span> <span class="o">=</span> <span class="n">side</span><span class="p">(</span><span class="n">P3P4</span><span class="p">,</span> <span class="n">P1</span><span class="p">)</span>
    <span class="n">P2_side</span> <span class="o">=</span> <span class="n">side</span><span class="p">(</span><span class="n">P3P4</span><span class="p">,</span> <span class="n">P2</span><span class="p">)</span>
    <span class="n">P3_side</span> <span class="o">=</span> <span class="n">side</span><span class="p">(</span><span class="n">P1P2</span><span class="p">,</span> <span class="n">P3</span><span class="p">)</span>
    <span class="n">P4_side</span> <span class="o">=</span> <span class="n">side</span><span class="p">(</span><span class="n">P1P2</span><span class="p">,</span> <span class="n">P4</span><span class="p">)</span>

    <span class="c1"># first case:</span>
    <span class="k">if</span> <span class="p">((</span><span class="n">P1_side</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">P2_side</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">P1_side</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">P2_side</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">))</span> <span class="ow">and</span>\
        <span class="p">((</span><span class="n">P3_side</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">P4_side</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">P3_side</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">P4_side</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)):</span>
        <span class="k">return</span> <span class="kc">True</span>
    <span class="k">elif</span> <span class="n">P1_side</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">onSegment</span><span class="p">(</span><span class="n">P3P4</span><span class="p">,</span> <span class="n">P1</span><span class="p">):</span>
        <span class="k">return</span> <span class="kc">True</span>
    <span class="k">elif</span> <span class="n">P2_side</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">onSegment</span><span class="p">(</span><span class="n">P3P4</span><span class="p">,</span> <span class="n">P2</span><span class="p">):</span>
        <span class="k">return</span> <span class="kc">True</span>
    <span class="k">elif</span> <span class="n">P3_side</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">onSegment</span><span class="p">(</span><span class="n">P1P2</span><span class="p">,</span> <span class="n">P3</span><span class="p">):</span>
        <span class="k">return</span> <span class="kc">True</span>
    <span class="k">elif</span> <span class="n">P4_side</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">onSegment</span><span class="p">(</span><span class="n">P1P2</span><span class="p">,</span> <span class="n">P4</span><span class="p">):</span>
        <span class="k">return</span> <span class="kc">True</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">False</span>
</code></pre></div>
<p>Implementation(<code>O(n lg n)</code>)</p>
<div class="highlight"><pre><span></span><code><span class="c1">## segment: [[[x1, y1], [x2, y2]], [[x1&#39;, y1&#39;], [x2&#39;, y2&#39;]]]</span>
<span class="c1">## each segment is represented as a [[], []], where the first [] contains the</span>
<span class="c1">## (x, y) of left endpoint p1 and the second [] has the right endpoint p2</span>
<span class="c1">## example</span>
<span class="c1">## return a above or lies on b at x0</span>
<span class="k">def</span><span class="w"> </span><span class="nf">segmentOrder</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">x0</span><span class="p">):</span>
    <span class="n">intersect</span> <span class="o">=</span> <span class="n">intersection</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">intersect</span><span class="p">:</span>
        <span class="n">leftSegment</span> <span class="o">=</span> <span class="n">a</span> <span class="k">if</span> <span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">else</span> <span class="n">b</span>
        <span class="n">rightSegment</span> <span class="o">=</span> <span class="n">b</span> <span class="k">if</span> <span class="n">leftSegment</span> <span class="o">==</span> <span class="n">a</span> <span class="k">else</span> <span class="n">a</span>
        <span class="k">if</span> <span class="n">side</span><span class="p">(</span><span class="n">leftSegment</span><span class="p">,</span> <span class="n">rightSegment</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">leftSegment</span> <span class="o">==</span> <span class="n">b</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">leftSegment</span> <span class="o">==</span> <span class="n">a</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># x be the intersection point of a &amp; b</span>
        <span class="c1"># x0 &gt; x</span>
        <span class="n">Right_to_intersection</span> <span class="o">=</span> <span class="p">((</span><span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span> <span class="o">*</span> <span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span> <span class="o">*</span> <span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span> <span class="o">-</span> <span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span> <span class="o">*</span> <span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span> <span class="o">*</span> <span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span> <span class="o">*</span> <span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span> <span class="o">*</span> <span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>  <span class="o">&lt;</span> \

        <span class="p">((</span><span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span> <span class="o">*</span> <span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span> <span class="o">*</span> <span class="n">x0</span>  <span class="o">-</span> <span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span> <span class="o">*</span> <span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span> <span class="o">*</span> <span class="n">x0</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">Right_to_intersection</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>


<span class="k">def</span><span class="w"> </span><span class="nf">above</span><span class="p">(</span><span class="n">T</span><span class="p">:</span> <span class="n">AVLTree</span><span class="p">,</span> <span class="n">s</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">T</span><span class="o">.</span><span class="n">predecessor</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>


<span class="k">def</span><span class="w"> </span><span class="nf">below</span><span class="p">(</span><span class="n">T</span><span class="p">:</span> <span class="n">AVLTree</span><span class="p">,</span> <span class="n">s</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">T</span><span class="o">.</span><span class="n">successor</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>


<span class="c1">## return True if e1 &gt; e2</span>
<span class="k">def</span><span class="w"> </span><span class="nf">comparison</span><span class="p">(</span><span class="n">e1</span><span class="p">,</span> <span class="n">e2</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">e1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">e2</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
        <span class="k">return</span> <span class="kc">True</span>
    <span class="k">elif</span> <span class="n">e1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">e2</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
        <span class="k">return</span> <span class="kc">False</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">e1</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">e2</span><span class="p">[</span><span class="mi">2</span><span class="p">]:</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">elif</span> <span class="n">e1</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">e2</span><span class="p">[</span><span class="mi">2</span><span class="p">]:</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">e1</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">e2</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>


<span class="k">def</span><span class="w"> </span><span class="nf">sift_down</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">i</span><span class="p">):</span>
    <span class="n">curr_p</span> <span class="o">=</span> <span class="n">i</span>
    <span class="k">while</span> <span class="n">curr_p</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">:</span>
        <span class="n">next_p</span> <span class="o">=</span> <span class="n">curr_p</span>
        <span class="n">l</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">curr_p</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="n">r</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">curr_p</span> <span class="o">+</span> <span class="mi">2</span>

        <span class="k">if</span> <span class="n">l</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="ow">and</span> <span class="n">comparison</span><span class="p">(</span><span class="n">h</span><span class="p">[</span><span class="n">next_p</span><span class="p">],</span> <span class="n">h</span><span class="p">[</span><span class="n">l</span><span class="p">]):</span>
            <span class="n">next_p</span> <span class="o">=</span> <span class="n">l</span>
        <span class="k">if</span> <span class="n">r</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="ow">and</span> <span class="n">comparison</span><span class="p">(</span><span class="n">h</span><span class="p">[</span><span class="n">next_p</span><span class="p">],</span> <span class="n">h</span><span class="p">[</span><span class="n">r</span><span class="p">]):</span>
            <span class="n">next_p</span> <span class="o">=</span> <span class="n">r</span>
        <span class="k">if</span> <span class="n">curr_p</span> <span class="o">!=</span> <span class="n">next_p</span><span class="p">:</span>
            <span class="n">h</span><span class="p">[</span><span class="n">curr_p</span><span class="p">],</span> <span class="n">h</span><span class="p">[</span><span class="n">next_p</span><span class="p">]</span> <span class="o">=</span> <span class="n">h</span><span class="p">[</span><span class="n">next_p</span><span class="p">],</span> <span class="n">h</span><span class="p">[</span><span class="n">curr_p</span><span class="p">]</span>
            <span class="n">curr_p</span> <span class="o">=</span> <span class="n">next_p</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">break</span>


<span class="k">def</span><span class="w"> </span><span class="nf">sortEndpoints</span><span class="p">(</span><span class="n">lineSegments</span><span class="p">):</span>
    <span class="n">acc</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">lineSegments</span><span class="p">)):</span>
        <span class="c1"># x-coord, y-coord, left/right, segmentID</span>
        <span class="n">acc</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">lineSegments</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">lineSegments</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="mi">0</span><span class="p">,</span> <span class="n">i</span><span class="p">))</span>
        <span class="n">acc</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">lineSegments</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">lineSegments</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="mi">1</span><span class="p">,</span> <span class="n">i</span><span class="p">))</span>

    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">acc</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span> <span class="o">//</span> <span class="mi">2</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
        <span class="n">sift_down</span><span class="p">(</span><span class="n">acc</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
        <span class="n">acc</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">acc</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">acc</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">acc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">sift_down</span><span class="p">(</span><span class="n">acc</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">acc</span>


<span class="k">def</span><span class="w"> </span><span class="nf">lineSweep</span><span class="p">(</span><span class="n">lineSegments</span><span class="p">):</span>
    <span class="n">T</span> <span class="o">=</span> <span class="n">AVLTree</span><span class="p">(</span><span class="n">segmentOrder</span><span class="p">)</span>
    <span class="n">events</span> <span class="o">=</span> <span class="n">sortEndpoints</span><span class="p">(</span><span class="n">lineSegments</span><span class="p">)</span>
    <span class="n">acc</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">events</span><span class="p">:</span>
        <span class="n">segmentID</span> <span class="o">=</span> <span class="n">p</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>
        <span class="n">s</span> <span class="o">=</span> <span class="n">lineSegments</span><span class="p">[</span><span class="n">segmentID</span><span class="p">]</span>
        <span class="n">up</span> <span class="o">=</span> <span class="n">above</span><span class="p">(</span><span class="n">T</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span>
        <span class="n">down</span> <span class="o">=</span> <span class="n">below</span><span class="p">(</span><span class="n">T</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">p</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">T</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">up</span> <span class="ow">and</span> <span class="n">intersection</span><span class="p">(</span><span class="n">up</span><span class="p">,</span> <span class="n">s</span><span class="p">):</span>
                <span class="n">acc</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">up</span><span class="p">,</span> <span class="n">s</span><span class="p">])</span>

            <span class="k">if</span> <span class="n">down</span> <span class="ow">and</span> <span class="n">intersection</span><span class="p">(</span><span class="n">down</span><span class="p">,</span> <span class="n">s</span><span class="p">):</span>
                <span class="n">acc</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">down</span><span class="p">,</span> <span class="n">s</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">up</span> <span class="ow">and</span> <span class="n">down</span> <span class="ow">and</span> <span class="n">intersection</span><span class="p">(</span><span class="n">up</span><span class="p">,</span> <span class="n">down</span><span class="p">):</span>
                <span class="n">acc</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">up</span><span class="p">,</span> <span class="n">down</span><span class="p">])</span>
            <span class="n">T</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">acc</span>
</code></pre></div>
<h2 id="18-bit-operation">18. Bit operation<a class="headerlink" href="#18-bit-operation" title="Permanent link">&para;</a></h2>
<p>bit operations:</p>
<div class="tabbed-set tabbed-alternate" data-tabs="9:1"><input checked="checked" id="__tabbed_9_1" name="__tabbed_9" type="radio" /><div class="tabbed-labels"><label for="__tabbed_9_1">Python</label></div>
<div class="tabbed-content">
<div class="tabbed-block">
<div class="highlight"><pre><span></span><code><span class="n">a</span> <span class="o">=</span> <span class="mi">4</span> <span class="o">^</span> <span class="mi">5</span>  <span class="c1"># a: 1(4 XOR 5 bitwise)</span>
<span class="n">a</span> <span class="o">=</span> <span class="n">a</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span> <span class="c1"># a: 0 (a // 2)</span>
<span class="n">a</span> <span class="o">=</span> <span class="n">a</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span> <span class="c1"># a: 2 (a * 2)</span>
<span class="n">a</span> <span class="o">=</span> <span class="mi">4</span> <span class="o">&amp;</span> <span class="mi">5</span>  <span class="c1"># a: 4 (a AND 5 bitwise)</span>
<span class="n">a</span> <span class="o">=</span> <span class="mi">4</span> <span class="o">|</span> <span class="mi">5</span>  <span class="c1"># a: 5 (a OR 5 bitwise)</span>
<span class="n">a</span> <span class="o">=</span> <span class="o">~</span><span class="mi">5</span>     <span class="c1"># a: -6 (reverse every bit of the number)</span>
</code></pre></div>
</div>
</div>
</div>
<p>application:
加减:</p>
<h2 id="19-mergesort">19. MergeSort<a class="headerlink" href="#19-mergesort" title="Permanent link">&para;</a></h2>
<p>In-place template:
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">Merge</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">r</span><span class="p">):</span>
    <span class="c1"># create 2 temporary backup arrays</span>
    <span class="n">larr</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="n">l</span><span class="p">:</span><span class="n">m</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
    <span class="n">rarr</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="n">m</span><span class="o">+</span><span class="mi">1</span><span class="p">:</span><span class="n">r</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>

    <span class="n">lsize</span><span class="p">,</span> <span class="n">rsize</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">larr</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">rarr</span><span class="p">)</span>
    <span class="n">pleft</span><span class="p">,</span> <span class="n">pright</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span>
    <span class="n">curr</span> <span class="o">=</span> <span class="n">l</span>

    <span class="k">while</span> <span class="n">pleft</span> <span class="o">&lt;</span> <span class="n">lsize</span> <span class="ow">and</span> <span class="n">pright</span> <span class="o">&lt;</span> <span class="n">risze</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">larr</span><span class="p">[</span><span class="n">pleft</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">rarr</span><span class="p">[</span><span class="n">pright</span><span class="p">]:</span>
            <span class="n">arr</span><span class="p">[</span><span class="n">curr</span><span class="p">]</span> <span class="o">=</span> <span class="n">larr</span><span class="p">[</span><span class="n">pleft</span><span class="p">]</span>
            <span class="n">pleft</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">arr</span><span class="p">[</span><span class="n">curr</span><span class="p">]</span> <span class="o">=</span> <span class="n">rarr</span><span class="p">[</span><span class="n">pright</span><span class="p">]</span>
            <span class="n">pright</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">curr</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="k">while</span> <span class="n">pleft</span> <span class="o">&lt;</span> <span class="n">lsize</span><span class="p">:</span>
        <span class="n">arr</span><span class="p">[</span><span class="n">curr</span><span class="p">]</span> <span class="o">=</span> <span class="n">larr</span><span class="p">[</span><span class="n">pleft</span><span class="p">]</span>
        <span class="n">pleft</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">curr</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="k">while</span> <span class="n">pright</span> <span class="o">&lt;</span> <span class="n">rsize</span><span class="p">:</span>
        <span class="n">arr</span><span class="p">[</span><span class="n">curr</span><span class="p">]</span> <span class="o">=</span> <span class="n">rarr</span><span class="p">[</span><span class="n">pright</span><span class="p">]</span>
        <span class="n">pright</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">curr</span> <span class="o">+=</span> <span class="mi">1</span>




<span class="k">def</span><span class="w"> </span><span class="nf">MergeSort</span><span class="p">(</span><span class="n">arr</span><span class="p">):</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>

    <span class="n">subArraySize</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">while</span> <span class="n">subArraySize</span> <span class="o">&lt;=</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>

        <span class="c1"># Merge every pair of subarrays in arr</span>
        <span class="n">l</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">while</span> <span class="n">l</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">mid</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">l</span> <span class="o">+</span> <span class="n">subArraySize</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">r</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">l</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">subArraySize</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>

            <span class="n">merge</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">mid</span><span class="p">,</span> <span class="n">r</span><span class="p">)</span>
            <span class="n">l</span> <span class="o">+=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">subArraySize</span>
        <span class="n">subArraySize</span> <span class="o">*=</span> <span class="mi">2</span>
</code></pre></div></p>












                
              </article>
            </div>
          
          
<script>var target=document.getElementById(location.hash.slice(1));target&&target.name&&(target.checked=target.name.startsWith("__tabbed_"))</script>
        </div>
        
      </main>
      
        <footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    
    
      
      <script id="__config" type="application/json">{"base": "..", "features": ["content.code.copy", "content.code.annotate"], "search": "../assets/javascripts/workers/search.973d3a69.min.js", "tags": null, "translations": {"clipboard.copied": "Copied to clipboard", "clipboard.copy": "Copy to clipboard", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.placeholder": "Type to start searching", "search.result.term.missing": "Missing", "select.version": "Select version"}, "version": null}</script>
    
    
      <script src="../assets/javascripts/bundle.f55a23d4.min.js"></script>
      
        <script src="../javascript/mathjax.js"></script>
      
        <script src="../javascript/collapseCodeblock.js"></script>
      
        <script src="https://unpkg.com/mathjax@3/es5/tex-mml-chtml.js"></script>
      
    
  </body>
</html>